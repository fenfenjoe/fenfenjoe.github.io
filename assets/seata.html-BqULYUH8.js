import{_ as a,c as e,a as r,o as n}from"./app-Dz2xZzfz.js";const d={};function s(o,t){return n(),e("div",null,t[0]||(t[0]=[r('<h1 id="分布式事务框架-seata" tabindex="-1"><a class="header-anchor" href="#分布式事务框架-seata"><span>分布式事务框架：SEATA</span></a></h1><h2 id="什么是分布式事务" tabindex="-1"><a class="header-anchor" href="#什么是分布式事务"><span>什么是分布式事务</span></a></h2><p>本地事务 ：<br> 用数据库本身提供的事务特性来实现，也叫数据库事务。</p><p><strong>分布式事务</strong> ：<br> 事务的参与者位于不同的节点、不同的应用，操作不同的数据库，单个数据库事务无法控制参与者的操作同时成功or同时失败<br> 因此有了分布式事务。</p><h2 id="seata简介" tabindex="-1"><a class="header-anchor" href="#seata简介"><span>Seata简介</span></a></h2><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。<br> Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><p>官方网站：<a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html" target="_blank" rel="noopener noreferrer">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p><h2 id="各模式的优缺点" tabindex="-1"><a class="header-anchor" href="#各模式的优缺点"><span>各模式的优缺点</span></a></h2><table><thead><tr><th>项目</th><th>AT模式</th><th>TCC模式</th><th>XA模式</th></tr></thead><tbody><tr><td>描述</td><td>会代理Datasource进行数据库操作，2PC模式的改良版</td><td>不会代理应用的数据库操作</td><td>X/Open组织定义了分布式事务接口，Oracle、mysql等厂商进行具体的实现</td></tr><tr><td>一致性</td><td>最终一致性</td><td></td><td>强一致性</td></tr><tr><td>整合方法</td><td>@GlobalTransactional + undo_log（事务回滚日志表）</td><td>@LocalTCC、@TwoPhaseBusinessAction、定义3个接口对应3个阶段</td><td>@GlobalTransactional</td></tr><tr><td>优点1</td><td>无侵入性，很少分布式事务相关代码</td><td>性能高，框架层面解决了空回滚、幂等性、防悬挂的问题</td><td>无侵入性，极少分布式事务相关代码</td></tr><tr><td>优点2</td><td>弥补了 XA 模式中资源锁定周期过长的缺点，增加了undo_log 机制，性能更好</td><td>应用自主程度高，事务参与者不局限于数据库，可延伸至其它组件如：Redis</td><td>支持任何实现了 XA 协议的数据源</td></tr><tr><td>缺点1</td><td>只能回滚数据库这种资源</td><td>侵入性高，应用需要以 TCC 规范去编写业务逻辑</td><td>只能回滚数据库这种资源</td></tr><tr><td>缺点2</td><td>不适合用于单个SQL修改大量数据的场景</td><td>改造成本大，对于存量业务来说，需要将原本的业务逻辑一分为三</td><td>性能差</td></tr><tr><td>适用场景</td><td>适用于依靠关系型数据库的保存数据的业务场景</td><td>对性能有较高要求的业务场景</td><td>适用于基于 XA 协议设计且无法进行改造的业务场景</td></tr></tbody></table><h2 id="at模式" tabindex="-1"><a class="header-anchor" href="#at模式"><span>AT模式</span></a></h2><p>AT模式中，假设有服务A，服务B，服务C</p><p>服务A，标记了@GlobalTransactional，因此服务A属于<strong>TM</strong>；<br> 服务B、C，被服务A调用，因此是<strong>RM</strong>；<br> 还有一个Seata-Server，负责全局事务的协调，是<strong>TC</strong>。</p><p>1.1 服务A向TC申请开启全局事务，获得一个全局事务ID（<strong>XID</strong>）； 1.2 调用服务B并带上XID；<br> 1.3 服务B向TC注册，并带上XID，好将服务B与服务A分到同一组；同时获得本地事务ID（<strong>BID</strong>）<br> 1.4 服务B在提交前，服务B会：1. 申请全局行锁 2. 生成<strong>事务前数据快照</strong>（before image） 1.5 服务B提交后，还会生成<strong>事务后数据快照</strong>（after image）<br> 1.6 然后，服务B提交事务执行结果 1.6.1 成功。根据before image，生成<strong>回滚SQL</strong>保存到undo_log里； 1.6.2 失败。根据after image，判断数据是否被脏读。有则报错，没有则事务回滚，并通知TC让其他本地事务回滚 1.7 服务C同理，按照1.3、1.4、1.5、1.6进行 1.8 服务A提交整体执行结果：（1）成功。TC通知服务A删除undo_log及其他事务管理数据；（2）失败：TM通知服务A所有本地事务回退</p><h2 id="tcc模式" tabindex="-1"><a class="header-anchor" href="#tcc模式"><span>TCC模式</span></a></h2><p>TCC模式中，有Try、Confirm、Cancel三个阶段。</p><p>假设现在有一个<strong>提交订单</strong>的场景。提交完订单后需要扣减库存。</p><p>2.1 Try阶段</p><ul><li>创建订单，并标注为<strong>未提交</strong></li><li>业务检查（是否有足够的库存扣减）</li><li>资源预留（冻结库存，冻结的库存其他业务不能使用）</li></ul><p>2.2 Confirm阶段</p><ul><li>将订单状态改为<strong>已提交</strong></li><li>冻结的库存<strong>取消冻结</strong>，正式扣减</li></ul><p>2.3 Cancel阶段</p><ul><li>删除未提交的订单</li><li>取消冻结的库存</li></ul><p>在锁使用的方面，整个实现TCC的过程，实际上是没有用到全局锁的，这是和AT模式另外一个大的区别。<br> TCC模式更多的是利用本地行锁或者乐观锁、状态区分的形式来实现资源隔离。<br> 因为没有全局锁的限制，所以其速度飞快提升。因此呢TCC模式也就适用于对性能有较高的分布式事务场景。</p><p>2.4 建立TCC模式的重试机制</p><p>confirm或者cancel方法也出现报错时，为了保证事务的最终一致性，我们应当做好重试机制处理：<br> 比如将请求发送MQ，然后再接收处理。</p><p>2.5 幂等性问题</p><p>如果扣减库存时多次重试，仍然能保证只扣了1次库存，这种就称为保证了<strong>幂等性</strong>。</p><p>换句话说，操作多次和操作一次的效果一样，就是所谓的幂等。</p><p>如何保证幂等性：</p><ul><li>添加状态字段，判断是否执行过</li></ul><p>2.6 悬挂问题（又叫空回滚）</p><p>所谓悬挂问题，就是二阶段模式中，<strong>cancel比try先执行</strong>。</p><p>拿上面的例子，cancel是解冻库存，try是将订单状态改为未提交。</p><p>2.6.1 因为网络问题，导致商品服务的try一直卡住，然后报错</p><p>2.6.2 TM通知库存服务回滚，执行了cancel方法，解冻了库存；</p><p>2.6.3 此时商品服务又好了，执行了try方法，将订单状态改为未提交；</p><p>2.6.4 然而事务已经被cancel过了，就不会再执行confirm，也就没有谁再来将资源状态从预处理更新为已处理了。</p><p>针对悬挂问题进行防悬挂处理，方案呢就是限制如果二阶段执行完成，一阶段就不能再执行。</p><p>当然这些处理呢，seata已经帮我们实现了，这也是使用现成的分布式事务框架的好处。省心！但是我们自己要知道这些问题和原理。</p><p>seata中的解决方案是增加一个<strong>事务记录表</strong>，在cancel阶段最后往事务记录表中插入一条记录（xid-status）标记cancel阶段已经执行过。<br> 此时try阶段进入时发现已经执行过回滚操作，则放弃try阶段的执行</p><h2 id="faq" tabindex="-1"><a class="header-anchor" href="#faq"><span>FAQ</span></a></h2><h3 id="at模式是如何弥补xa模式资源锁定周期过长这个缺点的" tabindex="-1"><a class="header-anchor" href="#at模式是如何弥补xa模式资源锁定周期过长这个缺点的"><span>AT模式是如何弥补XA模式资源锁定周期过长这个缺点的？</span></a></h3><p>AT模式不锁定资源，而是先生成执行前的数据快照，然后直接执行并提交；<br> 然后记录执行后的数据快照；<br> 一旦需要回滚了，便直接用旧的数据快照覆盖新的即可；</p><h3 id="什么是空回滚、幂等性、防悬挂" tabindex="-1"><a class="header-anchor" href="#什么是空回滚、幂等性、防悬挂"><span>什么是空回滚、幂等性、防悬挂？</span></a></h3><p>略</p><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><p>AT、tcc、XA 3种模式分别的原理：<a href="https://wu55555.blog.csdn.net/article/details/124510770" target="_blank" rel="noopener noreferrer">https://wu55555.blog.csdn.net/article/details/124510770</a></p>',47)]))}const i=a(d,[["render",s]]),c=JSON.parse('{"path":"/java/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/seata.html","title":"SEATA","lang":"en-US","frontmatter":{"title":"SEATA","sidebar":"heading"},"git":{"updatedTime":1750240340000,"contributors":[{"name":"dongyz8","username":"dongyz8","email":"dongyz8@gdii-yueyun.com","commits":3,"url":"https://github.com/dongyz8"}],"changelog":[{"hash":"ad8fc1a188d6829c38676e985c8e2097211af10d","time":1750240340000,"email":"dongyz8@gdii-yueyun.com","author":"dongyz8","message":"commit"},{"hash":"2107fe45a32694cb96e49385ca5e0106c7ec14a9","time":1732669486000,"email":"dongyz8@gdii-yueyun.com","author":"dongyz8","message":"commit"},{"hash":"df647d6e2be7a481aecf87bee52cf6dc8dde72d6","time":1724408079000,"email":"dongyz8@gdii-yueyun.com","author":"dongyz8","message":"commit"}]},"filePathRelative":"java/常用框架/seata.md"}');export{i as comp,c as data};
