import{_ as l,c as e,a,o}from"./app-neTUUq9d.js";const n={};function c(d,i){return o(),e("div",null,i[0]||(i[0]=[a('<h1 id="_2026年面试题" tabindex="-1"><a class="header-anchor" href="#_2026年面试题"><span>2026年面试题</span></a></h1><h2 id="_1-国际汇款延迟处理" tabindex="-1"><a class="header-anchor" href="#_1-国际汇款延迟处理"><span>1. 国际汇款延迟处理</span></a></h2><p>设计一个多币种汇款系统，若中间行处理超时，如何实现自动冲正（ReverseTransaction）？</p><p>答案：（AI）</p><ol><li>系统设计： <ul><li>创建一个交易记录表（本地消息表），记录交易的状态（如PENDING、PROCESSED、REVERSING、FAILED）。</li><li>引入事件驱动架构，使用消息队列（如Kafka、RabbitMQ）处理异步事件。</li><li>定义事件： <ul><li><code>TransactionCreated</code>:交易创建时触发</li><li><code>TransactionProcessed</code>:交易处理成功时触发</li><li><code>TransactionFailed</code>:交易处理失败时触发</li><li><code>TransactionTimeout</code>:交易处理超时时触发</li><li>事件触发：意思是消息队列把事件发送给事件处理程序，事件处理程序根据事件类型执行相应的逻辑。</li></ul></li></ul></li><li>超时检测： <ul><li>交易创建时，同步发送延迟消息至消息队列（Kafka、RokectMQ等），并设置超时时间（TTL）</li><li>消息到期后，触发<code>TransactionTimeout</code>事件</li><li>若交易处理成功，触发<code>TransactionProcessed</code>事件，此时需要把延迟消息从队列中移除。</li></ul></li><li>超时处理： <ul><li>事件处理程序检查发现未处理的<code>TransactionTimeout</code>事件。</li><li>如果没超过最大重试次数，则触发<code>ReverseTransaction</code>事件。</li></ul></li><li>冲正处理： <ul><li>当触发<code>ReverseTransaction</code>事件时</li><li>添加一个分布式锁，防止重复冲正处理</li><li>状态二次校验：确认交易仍处于REVERSING状态</li><li>调用中间行API执行冲正操作。</li><li>若冲正成功，触发<code>TransactionProcessed</code>事件。</li><li>若冲正失败，根据业务规则（如重试次数）触发<code>ReverseTransaction</code>事件。</li></ul></li></ol><h2 id="_2-重复支付防止" tabindex="-1"><a class="header-anchor" href="#_2-重复支付防止"><span>2. 重复支付防止</span></a></h2><p>用户因网络延迟重复提交付款请求，如何通过分布式锁（Redis/Zookeeper）和数据库唯一索引保证幂等性？</p><p>答案：</p><ol><li>方案1，分布式锁： <ul><li>客户端在提交付款请求前，尝试获取分布式锁（如Redis的<code>SETNX</code>命令或Zookeeper的<code>CREATE</code>命令）。</li><li>如果获取成功，继续处理请求；如果获取失败，说明有其他客户端在处理中，直接返回失败。</li></ul></li><li>方案2，数据库唯一索引： <ul><li>在数据库中为付款请求表添加一个唯一索引，例如基于<code>transaction_id</code>字段。</li><li>当客户端提交付款请求时，尝试插入数据库记录。</li><li>如果插入成功，说明是第一次请求，继续处理；如果插入失败（如唯一索引冲突），说明是重复请求，直接返回失败。</li></ul></li></ol><h2 id="_3-批量代发工资优化" tabindex="-1"><a class="header-anchor" href="#_3-批量代发工资优化"><span>3. 批量代发工资优化</span></a></h2><p>企业客户上传10万笔工资代发文件，如何用SpringBatch分片处理，并在处理失败时提供部分回滚机制？</p><p>答案：（AI）</p><ol><li>分片处理： <ul><li>使用SpringBatch的分片功能，将10万笔记录分成多个分片（如1000条记录为一个分片）。</li><li>每个分片独立处理，互不干扰。</li></ul></li><li>失败回滚： <ul><li>配置SpringBatch的<code>JobExecutionListener</code>，在处理失败时触发回滚。</li><li>回滚机制可以是回滚当前分片的处理，也可以是回滚整个Job的处理。</li><li>可以根据业务需求，选择合适的回滚策略。</li></ul></li></ol><h2 id="_4-账户余额并发更新" tabindex="-1"><a class="header-anchor" href="#_4-账户余额并发更新"><span>4. 账户余额并发更新</span></a></h2><p>高并发场景下（如秒杀活动），如何避免账户余额扣减的竞态条件？</p><p>答案：（AI）</p><ol><li>数据库事务： <ul><li>在每次账户余额扣减操作前，开启一个数据库事务。</li><li>在事务中执行查询操作，检查账户余额是否充足。</li><li>如果充足，执行扣减操作；如果不足，回滚事务。</li></ul></li><li>乐观锁： <ul><li>在账户表中添加一个版本号字段（如<code>version</code>）。</li><li>在每次账户余额扣减操作前，查询账户记录并获取当前版本号。</li><li>在执行扣减操作时，将版本号作为条件，只有当版本号未被修改时才执行更新操作。</li><li>如果更新失败（如版本号已被修改），说明有其他并发操作修改了账户余额，需要重新尝试。</li></ul></li></ol><p>对比悲观锁（SELECTFORUPDATE）和乐观锁（版本号）的实现？</p><ol><li>悲观锁： <ul><li>悲观锁假设会发生并发冲突，因此在操作数据前直接对数据加锁。</li><li>例如，在MySQL中使用<code>SELECTFORUPDATE</code>语句对查询结果加行级锁。</li><li>悲观锁适用于并发冲突比较严重的场景，能够确保数据的一致性。</li></ul></li><li>乐观锁： <ul><li>乐观锁假设不会发生并发冲突，因此在操作数据时不直接加锁，而是在更新数据时检查版本号是否被修改。</li><li>乐观锁适用于并发冲突比较少的场景，能够提高系统的吞吐量。</li></ul></li></ol><h2 id="_5-分布式事务与一致性" tabindex="-1"><a class="header-anchor" href="#_5-分布式事务与一致性"><span>5. 分布式事务与一致性</span></a></h2><p>在银行跨行转账场景下，如何确保分布式事务的一致性？</p><p>答案：（AI）</p><ol><li>两阶段提交（2PC）： <ul><li>协调者（Coordinator）协调多个参与者（Participants）的事务。</li><li>第一阶段（Prepare Phase）：协调者向所有参与者发送准备消息，询问是否可以提交事务。</li><li>第二阶段（Commit Phase）：如果所有参与者都回复可以提交，协调者向所有参与者发送提交消息；否则，发送回滚消息。</li></ul></li><li>补偿事务（SAGA模式）： <ul><li>将分布式事务拆分成多个本地事务，每个本地事务都有一个补偿操作。</li><li>如果某个本地事务失败，系统会执行其对应的补偿操作，回滚之前的操作。</li></ul></li></ol><h2 id="_6-日终批处理对账" tabindex="-1"><a class="header-anchor" href="#_6-日终批处理对账"><span>6. 日终批处理对账</span></a></h2><p>设计一个日终对账系统，对比核心银行系统与第三方支付渠道的交易流水，输出差异报告。如何用多线程加速千万级数据比对？</p><h2 id="_7-历史账户查询性能" tabindex="-1"><a class="header-anchor" href="#_7-历史账户查询性能"><span>7. 历史账户查询性能</span></a></h2><p>客户查询5年前交易记录时响应缓慢，请设计分表分库（按时间范围）和冷热数据分离方案（如ES归档），优化查询性能。</p><h2 id="_8-死信队列监控" tabindex="-1"><a class="header-anchor" href="#_8-死信队列监控"><span>8. 死信队列监控</span></a></h2><p>设计一个死信队列（DLO）告警机制，当支付消息处理失败超过3次时触发人工干预。</p><h2 id="_9-敏感数据加密" tabindex="-1"><a class="header-anchor" href="#_9-敏感数据加密"><span>9. 敏感数据加密</span></a></h2><p>客户姓名、证件号在数据库中如何加密？</p><h2 id="_10" tabindex="-1"><a class="header-anchor" href="#_10"><span>10.</span></a></h2>',32)]))}const r=l(n,[["render",c]]),t=JSON.parse('{"path":"/growup/2026/%E9%9D%A2%E8%AF%95%E9%A2%98.html","title":"2026年面试题","lang":"en-US","frontmatter":{},"git":{"updatedTime":1768976703000,"contributors":[{"name":"Fun_zil","username":"","email":"854257920@qq.com","commits":1},{"name":"dongyz8","username":"dongyz8","email":"dongyz8@gdii-yueyun.com","commits":1,"url":"https://github.com/dongyz8"}],"changelog":[{"hash":"e48c004e96800ad5847a42db01348565021df6fe","time":1768976703000,"email":"dongyz8@gdii-yueyun.com","author":"dongyz8","message":"commit"},{"hash":"6a6ceee8fc626def5d7f2df0947f6b16d32c69fd","time":1768750465000,"email":"854257920@qq.com","author":"Fun_zil","message":"commit"}]},"filePathRelative":"growup/2026/面试题.md"}');export{r as comp,t as data};
