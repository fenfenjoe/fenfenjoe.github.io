import{_ as s,c as a,a as e,o as p}from"./app-neTUUq9d.js";const l="/images/k8s1.png",t="/images/k8s2.png",o="/images/k8s3.png",i={};function r(c,n){return p(),a("div",null,n[0]||(n[0]=[e('<h1 id="kubernetes笔记" tabindex="-1"><a class="header-anchor" href="#kubernetes笔记"><span>Kubernetes笔记</span></a></h1><h3 id="写在开头" tabindex="-1"><a class="header-anchor" href="#写在开头"><span>写在开头</span></a></h3><ul><li><p>为什么叫K8S？ 因为K到S之间有8个字母。</p></li><li><p>为什么需要K8S？</p></li></ul><h3 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h3><p>【阿里云技术公开课】<a href="https://edu.aliyun.com/roadmap/cloudnative" target="_blank" rel="noopener noreferrer">https://edu.aliyun.com/roadmap/cloudnative</a><br> 【K8S官方中文文档】<a href="http://docs.kubernetes.org.cn/" target="_blank" rel="noopener noreferrer">http://docs.kubernetes.org.cn/</a><br> 【kuboard：免费K8S教程（图文）】<a href="https://kuboard.cn/learning/" target="_blank" rel="noopener noreferrer">https://kuboard.cn/learning/</a></p><h3 id="k8s的作用" tabindex="-1"><a class="header-anchor" href="#k8s的作用"><span>K8S的作用</span></a></h3><ul><li>服务发现和负载均衡</li><li>存储编排</li><li>自动部署和回滚</li><li>自动完成装箱（为容器选择物理主机，并将容器部署上去）</li><li>自我修复（容器所在主机出现故障，自动将容器迁移到别的主机上）</li><li>密钥与配置管理</li><li>批量执行</li><li>水平伸缩（发现容器所在主机负载过高，自动在别的主机部署多个容器副本，提高负载）</li></ul><h3 id="k8s的架构" tabindex="-1"><a class="header-anchor" href="#k8s的架构"><span>K8S的架构</span></a></h3><p><img src="'+l+'" alt="k8s1.png" loading="lazy"><img src="'+t+'" alt="k8s2.png" loading="lazy"></p><h4 id="master节点" tabindex="-1"><a class="header-anchor" href="#master节点"><span>Master节点</span></a></h4><p>有四大组件：</p><ul><li>API Server（组件之间均通过API Server进行通信）</li><li>Controller（负责容器状态管理。例如自我修复、水平伸缩等）</li><li>Schedular（调度器，负责容器的部署、装箱）</li><li>etcd（键值对数据库，分布式存储系统，保存API Server的元数据）</li></ul><figure><img src="'+o+`" alt="k8s3.png" tabindex="0" loading="lazy"><figcaption>k8s3.png</figcaption></figure><h4 id="node节点" tabindex="-1"><a class="header-anchor" href="#node节点"><span>Node节点</span></a></h4><p>有以下组件：</p><ul><li>pod（容器集）</li><li>Kubelet（容器生命周期管理、节点信息同步、接收并处理来自Master的请求）</li><li>Container-runtime（容器运行时、容器引擎） <ul><li>docker（1.20版本后开始弃用，原因：docker不支持CRI接口）</li><li>containerd</li><li>CRI-O</li></ul></li><li>Storage plugin</li><li>Network Plugin（kube-proxy）</li></ul><blockquote><p>pod 和 docker是什么关系？<br> docker是容器，负责装载我们应用程序的不同部分（mysql、前端、后端、redis等） pod则是容器集，包含多个容器，并由这些容器组成一个完整的应用；pod中的容器共享一些资源（数据卷、进程号、端口、域名主机名等） 参考：Linux namespace 资源隔离 沙箱技术</p></blockquote><h5 id="kube-proxy-管理pod之间的通信" tabindex="-1"><a class="header-anchor" href="#kube-proxy-管理pod之间的通信"><span>Kube-proxy（管理pod之间的通信）</span></a></h5><p>负责与本地Iptables打交道。</p><blockquote><p>什么是 Iptables？什么是IPVS？<br><strong>Linux防火墙的组件</strong><br> 在Linux系统中，由一个叫netfilter的框架提供真正的防火墙安全框架，运行在内核态；<br> 而Iptables、IPVS则是netfilter的代理，运行在用户态；<br> 用户通过操作Iptables、IPVS这些命令行工具，去操作真正的防火墙框架。</p></blockquote><blockquote><p>防火墙有什么功能？</p><ol><li>过滤报文</li><li>网络地址转换（NAT）</li><li>拆解报文，重新封装</li></ol></blockquote><blockquote><p>kube-proxy与userspace、iptables、ipvs是什么关系？<br> kube-proxy通过底层调用这些工具，去实现防火墙运维的功能。</p></blockquote><h4 id="其他插件" tabindex="-1"><a class="header-anchor" href="#其他插件"><span>其他插件</span></a></h4><h5 id="coredns-域名管理" tabindex="-1"><a class="header-anchor" href="#coredns-域名管理"><span>CoreDNS（域名管理）</span></a></h5><p>维护Service的IP与域名之间的映射关系</p><h5 id="dashboard-控制台" tabindex="-1"><a class="header-anchor" href="#dashboard-控制台"><span>Dashboard（控制台）</span></a></h5><p>可视化K8S控制台</p><h5 id="ingress-负载均衡" tabindex="-1"><a class="header-anchor" href="#ingress-负载均衡"><span>Ingress（负载均衡）</span></a></h5><p>有了kube-proxy的存在，为什么还需要Ingress？</p><p>Ingress可实现七层负载均衡</p><h5 id="federation-k8s集群管理系统" tabindex="-1"><a class="header-anchor" href="#federation-k8s集群管理系统"><span>Federation（K8S集群管理系统）</span></a></h5><h5 id="prometheus-k8s监控平台" tabindex="-1"><a class="header-anchor" href="#prometheus-k8s监控平台"><span>Prometheus（K8S监控平台）</span></a></h5><h5 id="elk-k8s日志分析平台" tabindex="-1"><a class="header-anchor" href="#elk-k8s日志分析平台"><span>ELK（K8S日志分析平台）</span></a></h5><h5 id="harbor-私有容器仓库" tabindex="-1"><a class="header-anchor" href="#harbor-私有容器仓库"><span>Harbor（私有容器仓库）</span></a></h5><h3 id="k8s工作流程的原理" tabindex="-1"><a class="header-anchor" href="#k8s工作流程的原理"><span>K8S工作流程的原理</span></a></h3><p><strong>部署一个容器组（POD）</strong></p><ol><li>用户提交一个POD（容器）到API Server；</li><li>API Server将POD信息保存到etcd；</li><li>API Server通知Schedular，为POD分配物理主机进行部署；</li><li>Schedular接收到请求，为POD选择装箱的节点，生成部署任务；</li><li>API Server收到部署任务，将部署任务先保存到etcd；</li><li>再将部署任务分发到相应的Node节点中；</li><li>Node中的Kubelet负责接收请求，并调用各种Plugin（Storage Plugin、Network Plugin、Kube-proxy组建网络、申请空间）</li><li>最后容器运行在Node的Container-Runtime中；</li></ol><h3 id="k8s的基础概念" tabindex="-1"><a class="header-anchor" href="#k8s的基础概念"><span>K8S的基础概念</span></a></h3><h4 id="资源清单-yaml" tabindex="-1"><a class="header-anchor" href="#资源清单-yaml"><span>资源清单（yaml）</span></a></h4><p>K8S的所有内容都被抽象化为资源。 资源实例化后，叫做对象。 资源通过<strong>资源清单</strong>来描述以及创建。</p><p>资源按如下分类：</p><p><strong>命名空间级别</strong></p><ul><li>工作负载型资源：Pod、ReplicaSet、Deployment、StatefulSet、DaemonSet、Job、CronJob</li><li>服务发现及负载均衡型资源：Ingress、Service...</li><li>配置与存储型资源：Volume（存储卷）、CSI（容器存储接口，可链接到第三方存储卷）</li><li>特殊类型的存储卷：ConfigMap（配置中心）、Secret（敏感数据）、DownwardAPI（将外部环境的信息输出给容器）</li></ul><p><strong>集群级别</strong> Namespace（命名空间）、Node（工作节点）、Role、ClusterRole、RoleBinding、ClusterRoleBinding</p><p><strong>元数据级别</strong> HPA、PodTemplate、LimitRange（资源限制）</p><p><strong>资源清单</strong>是用于资源创建的一个描述文件。</p><p>Pod资源清单示例：</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml"><pre><code class="language-yaml"><span class="line"><span class="token comment">#pod.yaml</span></span>
<span class="line"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1</span>
<span class="line"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod <span class="token comment">#资源类型（首字母必须大写）</span></span>
<span class="line"><span class="token key atrule">metadata</span><span class="token punctuation">:</span> <span class="token comment">#pod的基础信息</span></span>
<span class="line">  <span class="token key atrule">name</span><span class="token punctuation">:</span> myapp<span class="token punctuation">-</span>pod</span>
<span class="line">  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default</span>
<span class="line">  <span class="token key atrule">labels</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">app</span><span class="token punctuation">:</span> myapp</span>
<span class="line">    <span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token number">1.0</span></span>
<span class="line"><span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token comment">#详细的描述信息</span></span>
<span class="line">  <span class="token key atrule">containers</span><span class="token punctuation">:</span> <span class="token comment">#包含哪些容器</span></span>
<span class="line">  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span>  mysql <span class="token comment">#容器1：mysql</span></span>
<span class="line">    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span>latest</span>
<span class="line">    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&#39;sh&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;-c&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;echo the app is running!&#39;</span><span class="token punctuation">]</span> <span class="token comment">#启动后执行的脚本</span></span>
<span class="line">  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> readingness<span class="token punctuation">-</span>httpget<span class="token punctuation">-</span>container <span class="token comment">#容器2</span></span>
<span class="line">    <span class="token key atrule">image</span><span class="token punctuation">:</span> myapp<span class="token punctuation">:</span>v1</span>
<span class="line">    <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> IfNotPresent <span class="token comment">#镜像拉取策略：IfNotPresent为若本地没有则拉取</span></span>
<span class="line">    <span class="token key atrule">readinessProbe</span><span class="token punctuation">:</span> <span class="token comment">#定义一个就绪探针</span></span>
<span class="line">      <span class="token key atrule">httpGet</span><span class="token punctuation">:</span> </span>
<span class="line">        <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span></span>
<span class="line">        <span class="token key atrule">path</span><span class="token punctuation">:</span> /index.html</span>
<span class="line">      <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">3</span> <span class="token comment">#每3s检测一次</span></span>
<span class="line">    <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span> <span class="token comment">#定义了一个存活探针</span></span>
<span class="line">      <span class="token key atrule">exec</span><span class="token punctuation">:</span> <span class="token comment">#exec：通过执行某段脚本的返回值判断。还有httpGet、tcp（详见“探针”）</span></span>
<span class="line">        <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;-e&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;/tmp/live&quot;</span><span class="token punctuation">]</span> </span>
<span class="line">    <span class="token key atrule">lifeCycle</span><span class="token punctuation">:</span></span>
<span class="line">      <span class="token key atrule">preStart</span><span class="token punctuation">:</span> <span class="token comment">#容器启动前，执行的脚本（配置方法类似于探针）</span></span>
<span class="line">        <span class="token key atrule">exec</span><span class="token punctuation">:</span></span>
<span class="line">          <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">...</span></span>
<span class="line">      <span class="token key atrule">preStop</span><span class="token punctuation">:</span> <span class="token comment">#容器停止前，执行的脚本（配置方法类似于探针）</span></span>
<span class="line">        <span class="token key atrule">exec</span><span class="token punctuation">:</span></span>
<span class="line">          <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">...</span></span>
<span class="line">  <span class="token key atrule">initContainers</span><span class="token punctuation">:</span> <span class="token comment">#包含哪些Init容器</span></span>
<span class="line">  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span>  mysql<span class="token punctuation">-</span>init</span>
<span class="line">    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span>latest</span>
<span class="line">    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&#39;sh&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;-c&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;until nslookup mydb;do echo waiting for mydb;sleep 2; done;&#39;</span><span class="token punctuation">]</span> </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可通过以下命令查看资源清单有哪些属性</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token comment">#查看pod资源清单有哪些属性</span></span>
<span class="line">kubectl explain pod</span>
<span class="line"><span class="token comment">#查看pod资源清单的metadata有哪些属性</span></span>
<span class="line">kubectl explain pod.metadata</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>写好Pod的资源清单后，执行以下命令：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token comment">#按照资源清单部署资源</span></span>
<span class="line">kubectl apply <span class="token parameter variable">-f</span> pod.yaml</span>
<span class="line"><span class="token comment">#查看当前pod资源列表</span></span>
<span class="line">kubectl get pod</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="namespace-命名空间" tabindex="-1"><a class="header-anchor" href="#namespace-命名空间"><span>Namespace（命名空间）</span></a></h4><p>将Pod（容器集）、Deployment（容器集集群）、Service（网关）、Volume（存储卷）等资源进行逻辑分组，规划到一个小组内进行管理，这个小组便被称为一个Namespace； 同一个命名空间内的这些资源不允许重名，不同命名空间的可以重名；</p><p>用户资源所属默认的命名空间：default<br> 系统资源所属的命名空间：kube-system</p><h4 id="pod-容器集" tabindex="-1"><a class="header-anchor" href="#pod-容器集"><span>Pod（容器集）</span></a></h4><p>在集群中创建和部署的最小单元。一个pod部署在一台物理主机上。</p><p>一个Pod包含一个到多个容器。</p><p>支持多种容器环境（Docker、containerd、CRI-O）。</p><p>Pod内容器的端口不能冲突。</p><h5 id="pod的属性" tabindex="-1"><a class="header-anchor" href="#pod的属性"><span>Pod的属性</span></a></h5><p><strong>标签（Label）</strong> 格式：key:value</p><p>可以用标签对Pod进行标识；如标识某个Pod为前端应用、标识某个Pod为生产环境等。</p><p>查找Pod时可通过标签进行查找。用类似于SQL的方式（例如：ENV=prod）</p><p><strong>注解（annotations）</strong> 格式：key:value</p><p>类似于备注。可存储特殊字符。</p><p><strong>所有者（OwnerReference）</strong> Pod上面还可以组成一个Pod的集合。OwnerReference就是描述Pod与Pod集合之间的关系。</p><p>Pod集合包括：replicaset、statefulset</p><h5 id="特殊的容器-infra容器-又叫-pause容器" tabindex="-1"><a class="header-anchor" href="#特殊的容器-infra容器-又叫-pause容器"><span>特殊的容器：Infra容器（又叫“pause容器”）</span></a></h5><p>Infra容器是每个pod启动的第一个容器，负责准备pod需要的网络与数据卷；<br> Infra容器由系统自动维护，无需用户定义；<br> pod内：容器共享Infra容器的网络栈和挂载卷（使容器之间可通过localhost访问）；<br> pod外：容器通过Infra容器与其他pod的容器交互；<br> Infra容器存在于pod的整个生命周期中；</p><h5 id="特殊的容器-init容器" tabindex="-1"><a class="header-anchor" href="#特殊的容器-init容器"><span>特殊的容器：Init容器</span></a></h5><p>Init容器用于Pod中环境的准备，而且是一些不被建议放到应用程序容器镜像中的准备工作。<br> Init容器由用户自定义；<br> Init容器可以有0~n个；<br> Init容器只存在于Pod的初始化阶段；当Init容器完成任务后便会自行结束；</p><p><strong>Pod中容器共享的资源有：</strong><br> PID命名空间：Pod中的不同应用程序可以看到其他应用程序的进程ID；<br> 网络命名空间：Pod中的多个容器能够访问同一个IP和端口范围；<br> IPC命名空间：Pod中的多个容器能够使用SystemV IPC或POSIX消息队列进行通信；<br> UTS命名空间：Pod中的多个容器共享一个主机名；<br> Volumes（共享存储卷）：Pod中的各个容器可以访问在Pod级别定义的Volumes；</p><h4 id="deployment-集群" tabindex="-1"><a class="header-anchor" href="#deployment-集群"><span>Deployment（集群）</span></a></h4><p>ReplicaSet提供了命令式编程的方式来创建Pod（create）；<br> 而Deployment则提供了声明式编程的方式来创建Pod（apply）。</p><p><strong>Deployment的作用：</strong></p><ol><li>可确保Deployment中正常运行的Pod数量（当有Pod挂掉后，可自动重新发布一个Pod）</li><li>Pod版本更新若出现问题，支持一键回滚</li><li>可配置Pod版本更新的策略</li><li>支持滚动更新（rolling-update）</li></ol><p><strong>Deployment的用例：</strong> 将Pod分类，将不同类型的Pod分到不同的Deployment中，方便管理。<br> 例如：<br> Pod A：前端（3个）<br> Pod B：后端（3个）<br> Pod C：数据库（1个）<br> Pod D：网关（1个）<br> 可将3个前端的Pod（即Pod A）分到一个Deployment中。</p><p><strong>Deployment的工作原理：</strong> 当kubelet接到API Server的请求，需要滚动更新：</p><ol><li>为Deployment创建一个新RS（Replicaset，见“控制器”），由RS负责创建并管理新的Pod；</li><li>调用Deployment的旧RS，旧RS每删除一个旧的Pod，新RS便创建一个新的Pod，达到滚动更新；</li><li>当新pod数量达到期望值，停止创建。</li></ol><h4 id="service-网关、服务发现、负载均衡" tabindex="-1"><a class="header-anchor" href="#service-网关、服务发现、负载均衡"><span>Service（网关、服务发现、负载均衡）</span></a></h4><p>Service与Deployment一样，为一组Pod服务；<br> Deployment为Pod集群提供了版本更新的支持，Service则是作为Pod集群的代理，提供了服务注册、负载均衡的支持；<br> Service对应着一个IP+端口地址。</p><p>需要解决什么问题：<br> 服务注册的原理？<br> 如何进行负载均衡？</p><p>解决了什么问题：<br> Service等于在Nginx层和APP层的中间的一层；负责将APP Pod的服务动态注册到Nginx上；</p><p>Service的实现类型：<br><strong>ClusterIP</strong><br> 分配一个仅集群内部可以访问的IP:Port地址（ClusterIP），集群中的其他Pod便可通过ClusterIP访问Service，进而访问Service匹配的Pod集群；<br> Service会将请求通过iptables转发给kube-proxy，由kube-proxy负载均衡，将请求发送至合适的Pod。</p><blockquote><p><strong>Headless Service（无头服务）</strong><br> 也是ClusterIP Service的一种，它不向外部提供IP地址（ClusterIP=null）<br> 访问Headless Service需要通过CoreDNS中无头服务对应的主机名去访问。</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token comment">#查看CoreDNS信息  </span></span>
<span class="line">kubectl get pod <span class="token parameter variable">-n</span> kube-system <span class="token parameter variable">-o</span> wide  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p><strong>NodePort</strong><br> 在ClusterIP的基础上，将Service绑定到主机的某个端口中，外部机器就可以通过该端口访问到Service匹配的Pod集群；</p><p><strong>LodBalance</strong><br> 在NodePort的基础外加了一层云负载均衡（LAAS，需要租金）；<br> 即外部主机通过云负载均衡提供商去访问不同主机的NodePort，NodePort再转发请求给对应的Pod集群。</p><p><strong>ExternalName</strong><br> 把集群外部的服务注册到集群内部来，通过一个服务名进行访问。</p><h4 id="存储-etcd、configmap、secret、volume、pv" tabindex="-1"><a class="header-anchor" href="#存储-etcd、configmap、secret、volume、pv"><span>存储（etcd、configMap、secret、volume、PV）</span></a></h4><p>存储类型有：</p><ul><li>ConfigMap（配置文件注册中心，键值对存储）</li><li>Secret</li><li>Volume</li><li>Persistence Volume（PV）</li></ul><p><strong>ConfigMap</strong> K8S统一保存所有Pod的key-value键值对。</p><p>如何通过资源清单定义ConfigMap；<br> 如何在Pod资源清单的<strong>环境变量</strong>中调用ConfigMap；<br> 如何在Pod资源清单的<strong>命令</strong>中调用ConfigMap；<br> 如何在Pod资源清单中调用ConfigMap作为<strong>配置文件</strong>；</p><p><strong>Secret</strong><br> K8S统一保存所有Pod的密码、token、密钥等敏感信息。</p><p>有三种类型：</p><ul><li>Service Account</li><li>Opaque</li><li>kubernetes.io/dockerconfigjson</li></ul><p><strong>Volume</strong><br> Pod中的容器可共享的一个存储空间。容器之间可通过Volume（卷）共享文件。</p><p>K8S支持Volume的很多实现框架：<br> azureFile、cephfs、emptyDir、hostPath、nfs、gitRepo、glusterfs等等。</p><h4 id="控制器-controller" tabindex="-1"><a class="header-anchor" href="#控制器-controller"><span>控制器（Controller）</span></a></h4><p>下面是不同控制器的介绍。</p><hr><p><strong>replicaset（RS）</strong>：负责创建pod、删除pod，维持pod副本在期望数目</p><p>replication controller（RC）：功能与RS类似，但RS在RC基础上还支持集合式的selector（被推荐用replicaset取代）</p><hr><p><strong>statefulSet（有状态服务集）</strong>：解决有状态服务的问题。</p><blockquote><p>什么是有状态服务？ 就是服务器提供的服务，会保留用户请求的信息，就算有状态服务。 例如需要维护session的应用、持久化存储（数据库）等。 一般不推荐有状态服务部署到K8S。</p></blockquote><p>statefulSet的应用场景：</p><ul><li>持久化存储：pod重新调度后，依然能访问到相同的持久化数据，基于PVC</li><li>稳定的网络标志：pod重新调度后，PodName和Hostname保持不变，基于Headless Service</li><li>有序部署：将pod按照一定顺序部署（如先部署mysql、再部署app、再部署nginx），基于Init容器实现。</li><li>有序收缩：有序移除pod（先移除nginx，再app、mysql）</li></ul><hr><p><strong>DaemonSet（守护进程集）</strong>：在符合条件的节点上均部署某一类的pod。<br> 常用于以下场景：</p><ul><li>日志收集：如在每个节点均需要部署一个LogStash、Fluentd的容器</li><li>系统监控：Prometheus Node Exporter、Zabbix</li><li>集群存储：Glusterd、Ceph</li></ul><blockquote><p>与JAVA中AOP（面向切面）的思想类似。<br> 将日志收集、系统监控等的、基本上每个Node都需要用到的服务提取出来，作为一个切面；<br> 该切面有一个selector表达式，符合表达式的Node在加入集群时，DaemonSet会为它们新增一个Pod；反之，当这些Node退出集群时，这些Pod会被回收。</p></blockquote><hr><p><strong>Job、CronJob</strong>：负责批处理任务，即只执行一次的任务。<br> 常用于需要执行一些脚本的时候。<br> Job会创建一个或多个Pod去执行任务。</p><p>CronJob与Job类似，只不过CronJob可以周期性执行任务，Job是只执行一次。</p><hr><p><strong>horizontal pod autoscaling(HPA)</strong> ：通过监控资源使用情况（CPU、内存），提示控制器去控制pod的数量</p><hr><h4 id="网络" tabindex="-1"><a class="header-anchor" href="#网络"><span>网络</span></a></h4><p>Pod内容器之间的通信：lo（本机回环接口，pause容器的网络栈）<br> Pod与Pod之间的通信：Overlay Network<br> Pod与Service之间的通信：各节点的IPTables规则</p><p><strong>Flannel</strong><br> 可以使不同主机上创建的容器都具有全集群唯一的虚拟IP地址。</p><h4 id="调度器-schedular" tabindex="-1"><a class="header-anchor" href="#调度器-schedular"><span>调度器（Schedular）</span></a></h4><h4 id="探针-handler" tabindex="-1"><a class="header-anchor" href="#探针-handler"><span>探针（Handler）</span></a></h4><p>探针是由kubelet对容器进行的定期检测。</p><p>探针类型：</p><ul><li>ExecAction：在容器内执行指定命令，返回0则认为诊断成功。</li><li>TCPSocketAction：对指定端口的容器的IP地址进行TCP检查。端口打开的则认为诊断成功。</li><li>HTTPGetAction：对指定端口的容器的IP地址发送HTTP Get请求，返回状态码为200以上400以下则认为诊断成功。</li></ul><p>探针有两种用途：</p><ul><li><p>livenessProbe：存活探针。若这种类型的探针诊断失败，则K8S认为容器没有在运行，会将容器杀死，并且容器将受到<strong>重启策略</strong> 的影响。</p></li><li><p>readingProbe：就绪探针。若这种类型的探针诊断失败，则K8S认为该容器未准备好服务Service，并从Service的端点中删除该Pod的IP地址。</p></li></ul><h4 id="安全控制" tabindex="-1"><a class="header-anchor" href="#安全控制"><span>安全控制</span></a></h4><h4 id="helm-类似于linux中的yum-包管理工具" tabindex="-1"><a class="header-anchor" href="#helm-类似于linux中的yum-包管理工具"><span>HELM（类似于Linux中的yum，包管理工具）</span></a></h4><p>集群安装：例如通过helm安装mongodb集群、mysql集群</p><h3 id="kubernetes-组件" tabindex="-1"><a class="header-anchor" href="#kubernetes-组件"><span>Kubernetes 组件</span></a></h3><ul><li>kubectl：客户端命令行工具</li><li>kube-apiserver：服务端进程，以 REST API 服务提供接口。</li><li>kube-controller-manager：用来执行整个系统中的后台任务，包括节点状态状况、Pod 个数、Pods 和 Service 的关联等。</li><li>kube-scheduler（将 Pod 调度到 Node 上）：负责节点资源管理，接受来自 kube-apiserver 创建 Pods 任务，并分配到某个节点。</li><li>kubelet：运行在每个计算节点上，作为 agent，接受分配该节点的 Pods 任务及管理容器，周期性获取容器状态，反馈给 kube-apiserver。</li><li>DNS：一个可选的DNS服务，用于为每个 Service 对象创建 DNS 记录，这样所有的 Pod 就可以通过 DNS 访问服务了。</li></ul><p>编排管理层的组件：</p><ul><li>etcd：节点间的服务发现和配置共享。</li><li>kube-proxy：负责 Pod 网络代理。</li><li>flannel：云端网络配置，需要另外下载部署。</li></ul>`,136)]))}const u=s(i,[["render",r]]),m=JSON.parse('{"path":"/devops/kubernetes/kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","title":"Kubernetes笔记","lang":"en-US","frontmatter":{"title":"Kubernetes笔记","sidebar":"heading"},"git":{"updatedTime":1750240340000,"contributors":[{"name":"dongyz8","username":"dongyz8","email":"dongyz8@gdii-yueyun.com","commits":3,"url":"https://github.com/dongyz8"}],"changelog":[{"hash":"ad8fc1a188d6829c38676e985c8e2097211af10d","time":1750240340000,"email":"dongyz8@gdii-yueyun.com","author":"dongyz8","message":"commit"},{"hash":"2107fe45a32694cb96e49385ca5e0106c7ec14a9","time":1732669486000,"email":"dongyz8@gdii-yueyun.com","author":"dongyz8","message":"commit"},{"hash":"fb7cc624832f782b737cd66a5463ce109935379b","time":1709287696000,"email":"dongyz8@gdii-yueyun.com","author":"dongyz8","message":"commit"}]},"filePathRelative":"devops/kubernetes/kubernetes学习笔记.md"}');export{u as comp,m as data};
