import{_ as l,c as s,a as r,e as p,b as a,d as n,r as i,o}from"./app-neTUUq9d.js";const d={},h={class:"MathJax",jax:"SVG",style:{position:"relative"}},g={style:{"vertical-align":"-0.05ex"},xmlns:"http://www.w3.org/2000/svg",width:"1.054ex",height:"1.072ex",role:"img",focusable:"false",viewBox:"0 -452 466 474","aria-hidden":"true"},c={class:"MathJax",jax:"SVG",style:{position:"relative"}},b={style:{"vertical-align":"-0.05ex"},xmlns:"http://www.w3.org/2000/svg",width:"1.054ex",height:"1.072ex",role:"img",focusable:"false",viewBox:"0 -452 466 474","aria-hidden":"true"};function u(m,t){const e=i("ECharts");return o(),s("div",null,[t[12]||(t[12]=r('<h1 id="机器学习概述" tabindex="-1"><a class="header-anchor" href="#机器学习概述"><span>机器学习概述</span></a></h1><h2 id="什么是机器学习" tabindex="-1"><a class="header-anchor" href="#什么是机器学习"><span>什么是机器学习</span></a></h2><p>就是一个程序，用户将<strong>大量的历史数据</strong>提供给它，程序会根据<strong>既定的算法</strong>，从数据中总结出<strong>规律</strong>；<br> 最后训练出来的程序便可以根据<strong>当前的输入数据</strong>、按照自己总结的规律来预测结果。</p><p>在机器学习的概念中，“大量的历史数据”即指<strong>数据训练集</strong><br> “既定的算法”指<strong>机器模型</strong><br> “规律”则一般用<strong>数学的函数</strong>表示<br> “输入数据”指<strong>数据验证集</strong></p><p>上面的概念现在只需要知道有这么回事，后面会慢慢解释。</p><h2 id="机器学习研究的基本流程" tabindex="-1"><a class="header-anchor" href="#机器学习研究的基本流程"><span>机器学习研究的基本流程</span></a></h2><p><code>数据集准备 -&gt; 数据探索性分析（EDA）-&gt; 数据预处理 -&gt; 数据分割 -&gt;建立机器学习模型 -&gt;模型参数调优 -&gt; 提取特征 -&gt;机器学习任务-&gt; 模型性能评估</code></p><p>我们引入以下场景，通过一个实际的例子去了解机器学习的全过程：</p><p>银行需要预测“不同的人会过来银行借多少钱”。<br> 他们认为借钱的额度只与收入有关（实际上，可能还涉及其他因素，这里为方便只考虑收入）。<br> 于是他们统计出了以下表格：</p><p>表格1</p><table><thead><tr><th>客户</th><th>收入</th><th>借了多少钱</th></tr></thead><tbody><tr><td>A</td><td>3000</td><td>20000</td></tr><tr><td>B</td><td>4000</td><td>25000</td></tr><tr><td>C</td><td>6000</td><td>30000</td></tr><tr><td>D</td><td>10000</td><td>40000</td></tr><tr><td>E</td><td>2000</td><td>70000</td></tr></tbody></table><h3 id="_1-数据集准备" tabindex="-1"><a class="header-anchor" href="#_1-数据集准备"><span>1.数据集准备</span></a></h3><p>上面的表格1就是一个数据训练集，用来输入给我们的机器模型，让它能够从数据中“学习”，并总结出“规律”。</p><p>训练集分为两个部分：因子和标签。<br> 因子：我们认为的与结果有关的变量（在示例中即指用户的收入）<br> 标签：我们需要预测的结果（在示例中即指用户会借多少钱）</p><h3 id="_2-数据探索性分析-eda" tabindex="-1"><a class="header-anchor" href="#_2-数据探索性分析-eda"><span>2.数据探索性分析（EDA）</span></a></h3><p><strong>目标</strong>：通过可视化和统计方法理解数据的基本特征，发现数据中的模式、异常值、分布情况以及变量之间的关系，为后续处理提供依据。</p><p><strong>重要性</strong>：EDA是数据科学项目的基石，有助于确保数据质量，识别潜在问题（如异常值或缺失值），验证业务假设（如收入与借款额度的关系），并指导后续的预处理和建模步骤。忽略EDA可能导致模型基于错误假设，性能下降。</p><p><strong>详细过程</strong>：</p><ul><li><p><strong>描述性统计</strong>：计算关键统计量，如均值、中位数、标准差、最小值和最大值。例如，从表格1中：</p><ul><li><p><strong>收入均值</strong> = (3000 + 4000 + 6000 + 10000 + 2000) / 5 = 5000</p></li><li><p><strong>借款额度均值</strong> = (20000 + 25000 + 30000 + 40000 + 70000) / 5 = 37000</p></li><li><p><strong>收入标准差</strong> ≈ 3162，借款额度标准差 ≈ 18708，显示借款额度波动较大。</p></li></ul></li><li><p><strong>数据可视化</strong>：绘制散点图、直方图或箱线图。例如，散点图显示收入与借款额度的关系（见下图），可观察到收入增加时借款额度一般增加，但客户E（收入2000，借款70000）可能是一个异常值。</p></li></ul>',19)),p(e,{config:"eJyr5lJQUKpwrMgsVrJSAHGA3LzE3FQgT+nZlG1PW5cqAQVrdUDKKrEre9ow/9mafc+mbkCoLE4tykwFKY0GK4VoAIlX5ibl5wRnVoE0GhmA1ILFUxJLEuGqQQDBUlAwNjCAqwQBIyDfAM6PRUghazJB12RKhCYzNE0gmwlqMgQpQtYFspqgLpAnkDWZo2qCsuCalUoqC8CBXZycWFKSWgQKamBgA8lYrlouAJH7V5s=",title:"%E6%95%A3%E7%82%B9%E5%9B%BE"}),t[13]||(t[13]=r('<ul><li><p><strong>检查缺失值</strong>：本例中没有缺失值，但通常需使用isnull()函数检查。</p></li><li><p><strong>分布分析</strong>：检查收入与借款额度的分布是否正常。收入分布可能右偏（由于客户E），借款额度分布也可能右偏。</p></li><li><p><strong>相关性分析</strong>：计算皮尔逊相关系数。收入与借款额度的相关系数约为0.53，显示中等正相关，但受异常值影响。</p></li></ul><h3 id="_3-数据预处理" tabindex="-1"><a class="header-anchor" href="#_3-数据预处理"><span>3.数据预处理</span></a></h3><p><strong>目标</strong>：清理和转换原始数据，使其适合机器学习模型，包括处理异常值、缺失值、特征缩放等。</p><p><strong>重要性</strong>：原始数据往往包含噪声和不一致，预处理能提高模型稳定性、准确性和泛化能力。忽略预处理可能导致模型过拟合或欠拟合。</p><p><strong>详细过程</strong>：</p><ul><li><p><strong>处理缺失值</strong>：本例无缺失值，但若有，可用均值、中位数或插值法填充。</p></li><li><p><strong>处理异常值</strong>：从EDA中识别客户E为异常值（收入低但借款高），可考虑删除或调整。例如，删除E后数据更一致，但需业务判断是否合理。</p></li><li><p><strong>特征缩放</strong>：由于收入（2000-10000）和借款额度（20000-70000）范围差异大，使用标准化（Z-score）或归一化（Min-Max）。例如，归一化收入到[0,1]：收入_min=2000, 收入_max=10000，则客户A的收入归一化为(3000-2000)/(10000-2000)=0.125。</p></li><li><p><strong>数据编码</strong>：本例无分类变量，无需编码。如有，需one-hot编码。</p></li><li><p><strong>数据转换</strong>：考虑创建新特征，如收入分组或对数转换，以捕捉非线性关系。</p></li></ul><h3 id="_4-数据分割" tabindex="-1"><a class="header-anchor" href="#_4-数据分割"><span>4.数据分割</span></a></h3><p><strong>目标</strong>：将数据集分为训练集、验证集和测试集，以评估模型泛化能力。</p><p><strong>重要性</strong>：分割数据允许模型在训练集上学习，在验证集上调参，在测试集上最终评估，防止过拟合并确保模型对新数据的性能。</p><p><strong>详细过程</strong>：</p><ul><li><p><strong>分割比例</strong>：通常使用70-30或80-20分割。本例数据小（5个样本），可能不适用标准分割，建议使用留一法交叉验证（Leave-One-Out Cross-Validation, LOOCV），即每次用4个样本训练，1个测试，重复5次。</p></li><li><p><strong>随机分割</strong>：确保随机性，避免偏差。例如，使用sklearn的train_test_split函数，设置随机种子。</p></li><li><p><strong>分层分割</strong>：本例是回归问题，无需分层。但分类问题中，需保持类别比例。</p></li><li><p><strong>具体分割</strong>：在LOOCV中，每次迭代选择一个样本作为测试集，其余作为训练集。</p></li></ul><h3 id="_5-建立机器学习模型" tabindex="-1"><a class="header-anchor" href="#_5-建立机器学习模型"><span>5.建立机器学习模型</span></a></h3><p><strong>目标</strong>：选择并初始化一个机器学习模型，以学习数据中的模式。</p><p><strong>重要性</strong>：模型选择直接影响预测准确性。合适的模型能捕捉数据关系，而错误模型可能导致差性能。</p><p><strong>详细过程</strong>：</p><ul><li><p><strong>选择模型类型</strong>：本例是回归问题（预测连续值借款额度），因此选择回归模型，如简单线性回归（假设线性关系）或决策树回归（处理非线性）。</p></li><li><p><strong>模型初始化</strong>：例如，使用线性回归模型：借款额度 = w * 收入 + b，其中w和b为参数。</p></li><li><p><strong>训练模型</strong>：使用训练集数据拟合模型。例如，在线性回归中，使用最小二乘法或梯度下降优化w和b。</p></li><li><p><strong>实现工具</strong>：使用Python库如scikit-learn，代码示例略</p></li></ul><h3 id="_6-模型参数调优" tabindex="-1"><a class="header-anchor" href="#_6-模型参数调优"><span>6.模型参数调优</span></a></h3><p><strong>目标</strong>：调整模型超参数以优化性能，平衡过拟合和欠拟合。</p><p><strong>重要性</strong>：超参数（如学习率、正则化参数）控制模型行为，调优能显著提高准确性和泛化能力。</p><p><strong>详细过程</strong>：</p><ul><li><p><strong>识别超参数</strong>：对于线性回归，可能无超参数，但若使用正则化（如Ridge或Lasso），需调优正则化强度α。</p></li><li><p><strong>使用验证集</strong>：在验证集上评估不同参数性能。本例由于数据小，可使用交叉验证的验证分数。</p></li><li><p><strong>调优方法</strong>：</p><ul><li><p><strong>网格搜索</strong>：系统遍历参数组合，例如<code>α=[0.1, 1, 10]</code>。</p></li><li><p><strong>随机搜索</strong>：随机采样参数空间。</p></li></ul></li><li><p><strong>评估指标</strong>：使用均方误差（MSE）或R²分数选择最佳参数。</p></li><li><p><strong>示例</strong>：如果使用Ridge回归，通过网格搜索找到最佳α，使得验证集MSE最小。</p></li></ul><h3 id="_7-提取特征" tabindex="-1"><a class="header-anchor" href="#_7-提取特征"><span>7.提取特征</span></a></h3><p><strong>目标</strong>：从原始数据中创建或选择相关特征，以增强模型预测能力。</p><p><strong>重要性</strong>：特征工程是机器学习成功的关键，好的特征能捕捉数据中隐藏模式，减少噪声，提高模型性能。</p><p><strong>详细过程</strong>：</p><ul><li><p><strong>特征工程</strong>：基于业务知识创建新特征。例如：</p></li><li><p><strong>创建多项式特征</strong>：收入²或收入³，以捕捉非线性关系。</p></li><li><p><strong>创建交互特征</strong>：如果有其他特征（如年龄），可与收入组合。</p></li><li><p><strong>特征选择</strong>：使用统计方法（如相关性分析）或模型基方法（如特征重要性）选择关键特征。本例只有收入特征，但可评估收入与借款额度的相关性，决定是否保留。</p></li><li><p><strong>维度缩减</strong>：如果特征多，可使用PCA降维，但本例无需。</p></li><li><p><strong>示例</strong>：从EDA中，收入与借款额度相关性中等，可尝试添加收入平方特征，看看是否改善模型。</p></li></ul><h3 id="_8-机器学习任务" tabindex="-1"><a class="header-anchor" href="#_8-机器学习任务"><span>8.机器学习任务</span></a></h3><p><strong>目标</strong>：明确机器学习任务类型（如回归、分类），并定义损失函数和优化算法。</p><p><strong>重要性</strong>：任务定义指导模型选择、评估指标和优化方向，确保问题正确建模。</p><p><strong>详细过程</strong>：</p><ul><li><p><strong>任务识别</strong>：本例是回归任务，因为预测连续值（借款额度）。</p></li><li><p><strong>选择损失函数</strong>：回归任务常用均方误差（MSE）或平均绝对误差（MAE）。例如，MSE = Σ(预测值 - 真实值)² / n。</p></li><li><p><strong>选择优化算法</strong>：如梯度下降法用于最小化损失函数。在线性回归中，可使用普通最小二乘法或随机梯度下降。</p></li><li><p><strong>模型训练</strong>：根据任务和损失函数训练模型。例如，最小化MSE学习参数w和b。</p></li></ul><h3 id="_9-模型性能评估" tabindex="-1"><a class="header-anchor" href="#_9-模型性能评估"><span>9.模型性能评估</span></a></h3><p><strong>目标</strong>：评估模型在未见数据上的性能，确保其泛化能力。</p><p><strong>重要性</strong>：评估帮助确认模型是否有效，避免过拟合，并为部署提供依据。忽略评估可能导致模型在实际中失败。</p><p><strong>详细过程</strong>：</p><ul><li><p><strong>使用测试集</strong>：在最终测试集上计算性能指标。本例由于数据小，使用LOOCV的平均性能。</p></li><li><p><strong>性能指标</strong>：对于回归，常用：</p><ul><li><p><strong>MSE（均方误差）</strong>：值越小越好。</p></li><li><p><strong>RMSE（均方根误差）</strong>：与目标变量同单位。</p></li><li><p><strong>MAE（平均绝对误差）</strong>：鲁棒性强。</p></li><li><p><strong>R²分数</strong>：解释方差比例，1为最佳。</p></li></ul></li><li><p><strong>交叉验证</strong>：使用LOOCV，计算5次迭代的MSE平均值为最终评估。</p></li><li><p><strong>示例</strong>：假设线性回归模型在LOOCV上的MSE为1000000，R²为0.6，表示模型解释60%方差，但可能受异常值影响。</p></li><li><p><strong>结果分析</strong>：比较模型与基准（如均值预测），并可视化预测 vs 真实值。</p></li></ul><h2 id="常见的机器学习模型" tabindex="-1"><a class="header-anchor" href="#常见的机器学习模型"><span>常见的机器学习模型</span></a></h2><ul><li><p>逻辑回归（Logistic Regression）</p></li><li><p>决策树（Decision Tree）</p></li><li><p>随机森林（Random Forest）：是由多个决策树构成的集成模型</p></li><li><p>支持向量机（Support Vector Machine，SVM）</p></li><li><p>神经网络（Neural Network）</p></li><li><p>卷积神经网络（Convolutional Neural Network，CNN）：一种特殊的神经网络</p></li><li><p>循环神经网络（Recurrent Neural Network，RNN）</p></li><li><p>生成对抗网络（Generative Adversarial Network，GAN）：由两个神经网络组成，分别为生成器和判别器，通过对抗训练的方式来生成新的数据</p></li></ul><h2 id="faq" tabindex="-1"><a class="header-anchor" href="#faq"><span>FAQ</span></a></h2><h3 id="_1-学习机器学习之前应该掌握哪些学科" tabindex="-1"><a class="header-anchor" href="#_1-学习机器学习之前应该掌握哪些学科"><span>1.学习机器学习之前应该掌握哪些学科？</span></a></h3><ul><li>线性代数：机器学习中涉及很多矩阵的计算。</li></ul><h3 id="_2-什么是机器学习" tabindex="-1"><a class="header-anchor" href="#_2-什么是机器学习"><span>2.什么是机器学习？</span></a></h3><p>传统的程序： 输入（数据） + 代码 = 输出（结果）</p><blockquote><p>我们运行代码，然后输入数据，程序会帮我们计算出结果。</p></blockquote><p>机器学习程序： 输入（数据） + 输出（结果） 训练出 代码</p><blockquote><p>通过数据训练出能预测结果的程序，就是机器学习。</p></blockquote><h3 id="_3-机器学习训练出来的程序主要解决什么问题" tabindex="-1"><a class="header-anchor" href="#_3-机器学习训练出来的程序主要解决什么问题"><span>3.机器学习训练出来的程序主要解决什么问题？</span></a></h3><p>根据需要预测的结果是离散型的还是连续型的，分为两大类问题：</p><ul><li><p>分类</p><blockquote><p>对离散型变量进行预测。比如：</p><ul><li>识别动物是猪牛鸡鸭中的哪种；</li><li>识别颜色；</li><li>鉴别女生是否漂亮；</li></ul></blockquote></li><li><p>回归</p><blockquote><p>对连续型变量进行预测。比如：</p><ul><li>房价走势；股票走势；</li><li>一年内气温变化；</li></ul></blockquote></li></ul><p>不同类型的问题需要建立不同的机器学习模型来研究。</p><h3 id="_4-机器学习与深度学习的区别" tabindex="-1"><a class="header-anchor" href="#_4-机器学习与深度学习的区别"><span>4.机器学习与深度学习的区别？</span></a></h3><p>我们可以通过两者的研究流程，看看两者的区别</p><table><thead><tr><th>步骤</th><th>机器学习</th><th>深度学习</th></tr></thead><tbody><tr><td>1</td><td>数据集准备</td><td>数据集准备</td></tr><tr><td>2</td><td>探索性地对数据进行分析（EDA）</td><td></td></tr><tr><td>3</td><td>数据预处理</td><td>数据预处理</td></tr><tr><td>4</td><td>数据分割（训练集 &amp; 测试集）</td><td>数据分割（训练集 &amp; 测试集）</td></tr><tr><td>5</td><td>建立机器学习模型</td><td>定义神经网络模型</td></tr><tr><td>6</td><td>模型参数调优</td><td>模型参数调优</td></tr><tr><td>7</td><td>提取特征</td><td></td></tr><tr><td>8</td><td>机器学习任务（回归or分类）</td><td>训练网络</td></tr><tr><td>9</td><td>模型性能评估</td><td></td></tr></tbody></table><p>实际上，深度学习属于一种特殊的机器学习流程。<br> 由上可见，深度学习省略了提取特征（特征工程）的步骤；同时，建模过程也缩短了，用神经网络代替了之前百花齐放的机器学习算法。</p><blockquote><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MjM5Nzk5MjA5Mw==&amp;mid=2652749788&amp;idx=1&amp;sn=0fed32336bbec174f942214ab86fd2d4&amp;chksm=bd389c2e8a4f15383fccbded9ef0ca5061fe4acfba1b42de5c31d347a0b1a51d77b74c87eea0&amp;scene=27" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s?__biz=MjM5Nzk5MjA5Mw==&amp;mid=2652749788&amp;idx=1&amp;sn=0fed32336bbec174f942214ab86fd2d4&amp;chksm=bd389c2e8a4f15383fccbded9ef0ca5061fe4acfba1b42de5c31d347a0b1a51d77b74c87eea0&amp;scene=27</a></p></blockquote><h3 id="_5-什么是特征" tabindex="-1"><a class="header-anchor" href="#_5-什么是特征"><span>5.什么是特征？</span></a></h3><p>见“数据集准备”</p><h3 id="_6-有哪些机器模型-机器模型如何总结出-规律" tabindex="-1"><a class="header-anchor" href="#_6-有哪些机器模型-机器模型如何总结出-规律"><span>6.有哪些机器模型？机器模型如何总结出“规律”？</span></a></h3><p>见“建立机器学习模型”</p><h3 id="_7-什么是回归-什么是分类" tabindex="-1"><a class="header-anchor" href="#_7-什么是回归-什么是分类"><span>7.什么是回归？什么是分类？</span></a></h3><p>见“机器学习任务”</p><h3 id="_8-什么是有监督算法-什么是无监督算法" tabindex="-1"><a class="header-anchor" href="#_8-什么是有监督算法-什么是无监督算法"><span>8.什么是有监督算法？什么是无监督算法？</span></a></h3><p>略</p><h2 id="相关概念解释" tabindex="-1"><a class="header-anchor" href="#相关概念解释"><span>相关概念解释</span></a></h2><h3 id="回归" tabindex="-1"><a class="header-anchor" href="#回归"><span>回归</span></a></h3><blockquote></blockquote><h3 id="分类" tabindex="-1"><a class="header-anchor" href="#分类"><span>分类</span></a></h3><blockquote></blockquote><h3 id="特征" tabindex="-1"><a class="header-anchor" href="#特征"><span>特征</span></a></h3><blockquote><p>形容样本有多少个需要取样的“属性”；<br> 比如某个银行判断可以借多少钱给某个人，可能需要获得这个人（样本）的“年薪”、“年龄”这两个特征（属性），去进行判断。</p></blockquote><h3 id="拟合" tabindex="-1"><a class="header-anchor" href="#拟合"><span>拟合</span></a></h3><blockquote></blockquote><h3 id="过拟合" tabindex="-1"><a class="header-anchor" href="#过拟合"><span>过拟合</span></a></h3><blockquote></blockquote><h3 id="偏置项" tabindex="-1"><a class="header-anchor" href="#偏置项"><span>偏置项</span></a></h3><blockquote></blockquote><h3 id="误差项" tabindex="-1"><a class="header-anchor" href="#误差项"><span>误差项</span></a></h3>',77)),a("blockquote",null,[a("p",null,[t[2]||(t[2]=n("真实值与预测值之间存在的差异。一般用")),a("mjx-container",h,[(o(),s("svg",g,t[0]||(t[0]=[a("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[a("g",{"data-mml-node":"math"},[a("g",{"data-mml-node":"mi"},[a("path",{"data-c":"1D700",d:"M190 -22Q124 -22 76 11T27 107Q27 174 97 232L107 239L99 248Q76 273 76 304Q76 364 144 408T290 452H302Q360 452 405 421Q428 405 428 392Q428 381 417 369T391 356Q382 356 371 365T338 383T283 392Q217 392 167 368T116 308Q116 289 133 272Q142 263 145 262T157 264Q188 278 238 278H243Q308 278 308 247Q308 206 223 206Q177 206 142 219L132 212Q68 169 68 112Q68 39 201 39Q253 39 286 49T328 72T345 94T362 105Q376 103 376 88Q376 79 365 62T334 26T275 -8T190 -22Z"})])])],-1)]))),t[1]||(t[1]=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("mi",null,"ε")])],-1))]),t[3]||(t[3]=n("表示。"))])]),t[14]||(t[14]=a("h3",{id:"损失函数",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#损失函数"},[a("span",null,"损失函数")])],-1)),a("blockquote",null,[a("p",null,[t[6]||(t[6]=n("当我们计算出了一个数学模型后，我们便可以用模型计算出一系列的预测值；")),t[7]||(t[7]=a("br",null,null,-1)),t[8]||(t[8]=n(" 每一个预测值与真实值肯定有误差（")),a("mjx-container",c,[(o(),s("svg",b,t[4]||(t[4]=[a("g",{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"},[a("g",{"data-mml-node":"math"},[a("g",{"data-mml-node":"mi"},[a("path",{"data-c":"1D700",d:"M190 -22Q124 -22 76 11T27 107Q27 174 97 232L107 239L99 248Q76 273 76 304Q76 364 144 408T290 452H302Q360 452 405 421Q428 405 428 392Q428 381 417 369T391 356Q382 356 371 365T338 383T283 392Q217 392 167 368T116 308Q116 289 133 272Q142 263 145 262T157 264Q188 278 238 278H243Q308 278 308 247Q308 206 223 206Q177 206 142 219L132 212Q68 169 68 112Q68 39 201 39Q253 39 286 49T328 72T345 94T362 105Q376 103 376 88Q376 79 365 62T334 26T275 -8T190 -22Z"})])])],-1)]))),t[5]||(t[5]=a("mjx-assistive-mml",{unselectable:"on",display:"inline"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("mi",null,"ε")])],-1))]),t[9]||(t[9]=n("）； 损失函数就是将所有误差作为入参，统计出该数学模型整体误差值（或叫精确度）的工具。")),t[10]||(t[10]=a("br",null,null,-1)),t[11]||(t[11]=n(" 如果发现这个“整体误差值”太大，我们便需要对数学模型进行调参； 然后重新通过损失函数计算“整体误差值”，直到其到达我们能接受的范围。"))])]),t[15]||(t[15]=r('<h3 id="模型的鲁棒性" tabindex="-1"><a class="header-anchor" href="#模型的鲁棒性"><span>模型的鲁棒性</span></a></h3><blockquote><p>可以理解为“健壮性”，形容当输入的数据错误时，系统能否正常运行。</p></blockquote><h3 id="独立同分布" tabindex="-1"><a class="header-anchor" href="#独立同分布"><span>独立同分布</span></a></h3><blockquote><p>用来形容两个随机变量（假设为X1和X2）服从同一分布（同分布），且X1的取值不会影响到X2的取值（独立）；<br> 对于多次重复实验，像抛硬币，就可以认为第一次抛硬币的结果（X1）和第二次抛硬币的结果（X2）是独立同分布的。</p></blockquote><h3 id="高斯分布" tabindex="-1"><a class="header-anchor" href="#高斯分布"><span>高斯分布</span></a></h3><blockquote></blockquote><h3 id="似然函数" tabindex="-1"><a class="header-anchor" href="#似然函数"><span>似然函数</span></a></h3><blockquote></blockquote><h3 id="偏导" tabindex="-1"><a class="header-anchor" href="#偏导"><span>偏导</span></a></h3><blockquote></blockquote><h3 id="梯度下降" tabindex="-1"><a class="header-anchor" href="#梯度下降"><span>梯度下降</span></a></h3><blockquote></blockquote><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p>B站视频：机器学习入门到精通！...</p>',14))])}const x=l(d,[["render",u]]),k=JSON.parse('{"path":"/machineLearning/","title":"机器学习","lang":"en-US","frontmatter":{"title":"机器学习","sidebar":"heading","sidebarDepth":1},"git":{"updatedTime":1761213989000,"contributors":[{"name":"dongyz8","username":"dongyz8","email":"dongyz8@gdii-yueyun.com","commits":4,"url":"https://github.com/dongyz8"}],"changelog":[{"hash":"144ff42325a1305cb76ccc36b9ccb03773c86836","time":1761213989000,"email":"dongyz8@gdii-yueyun.com","author":"dongyz8","message":"commit"},{"hash":"ad8fc1a188d6829c38676e985c8e2097211af10d","time":1750240340000,"email":"dongyz8@gdii-yueyun.com","author":"dongyz8","message":"commit"},{"hash":"5c9ebb4a07b7856d42550142a45aa8d9327f347c","time":1743157920000,"email":"dongyz8@gdii-yueyun.com","author":"dongyz8","message":"commit"},{"hash":"45b5590437faf102707a4627c085a1bcba76a5a3","time":1740293597000,"email":"dongyz8@gdii-yueyun.com","author":"dongyz8","message":"commit"}]},"filePathRelative":"machineLearning/README.md"}');export{x as comp,k as data};
