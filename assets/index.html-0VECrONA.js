import{_ as s,c as n,a as e,o as l}from"./app-Dz2xZzfz.js";const i={};function p(t,a){return l(),n("div",null,a[0]||(a[0]=[e(`<h1 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm"><span>JVM</span></a></h1><h5 id="jvm内存模型" tabindex="-1"><a class="header-anchor" href="#jvm内存模型"><span>JVM内存模型</span></a></h5><ul><li>进程控制块 <ul><li>程序计数器</li></ul></li><li>本地接口</li><li>运行时数据区 <ul><li>堆------------------------------存储对象、字符串常量（1.7之后） <ul><li>新生代------------------------对象 <ul><li>Eden区（80%）</li><li>Survivor1区（10%）</li><li>Survivor2区（10%）</li></ul></li><li>老年代------------------------对象</li><li>永久代（1.7之前作为方法区）-----静态变量、常量、类信息</li></ul></li><li>方法区--------------------------存储类信息、静态变量和常量值</li><li>线程空间 <ul><li>栈----------------------------存储基本类型变量和对象引用</li><li>线程控制块</li><li>虚拟缓存</li></ul></li></ul></li></ul><p>1.7之前：</p><ul><li>基本数据类型变量(int,float,double等) —— 栈帧（线程空间）</li><li>对象引用 —— 栈帧（线程空间）</li><li>静态变量 —— 堆-&gt; 永久代（被称为方法区）</li><li>常量值 —— 堆-&gt; 永久代（被称为方法区）</li><li>类信息(.class) —— 堆-&gt; 永久代（被称为方法区）</li><li>字符串常量值 —— 字符串常量池</li><li>对象 —— 堆 -&gt; 新生代、老年代</li></ul><p>1.7之后：</p><ul><li>基本数据类型变量(int,float,double等) —— 栈帧（线程空间）</li><li>对象引用 —— 栈帧（线程空间）</li><li>静态变量 —— 堆</li><li>常量值 —— 元数据metaspace（也被称为方法区）</li><li>类信息(.class) —— 元数据metaspace（也被称为方法区）</li><li>字符串常量值 —— 堆-&gt; 字符串常量池</li><li>对象 —— 堆 -&gt; 新生代、老年代</li></ul><blockquote><p>简单来讲：</p><ul><li>栈帧：存储基本类型变量和对象引用；</li><li>方法区：存储类信息和常量值；1.7之前在堆里，1.7后独立出来，命名为元数据metaspace；</li><li>堆：存储对象，分为新生代、老年代；永久代只有1.7之前有，1.7后独立出来被称为元数据metaspace；</li><li>字符串常量池：存储字符串常量，1.7之前在堆外、1.7之后移到了堆内。</li></ul></blockquote><h5 id="java对象在内存里占用多少空间" tabindex="-1"><a class="header-anchor" href="#java对象在内存里占用多少空间"><span>Java对象在内存里占用多少空间？</span></a></h5><p>首先需要知道对象的数据结构：</p><ul><li>对象头 <ul><li>对象基本信息（锁、线程ID等）：8 bytes</li><li>对象指针：4 bytes（开启指针压缩时）、8 bytes（没开启指针压缩时）</li><li>数组长度：4 bytes</li></ul></li><li>实例内容 <ul><li>boolean:1 bytes</li><li>byte:1 bytes</li><li>short:2 bytes</li><li>char:2 bytes</li><li>int:4 bytes</li><li>float:4 bytes</li><li>long:8 bytes</li><li>double:8 bytes</li><li>Reference:4 bytes（开启指针压缩时）、8 bytes（没开启指针压缩时）</li></ul></li><li>填充内容 <ul><li>仅为了保证对象大小为8 bytes的整数倍</li></ul></li></ul><blockquote><p>指针压缩默认为开启，对应JVM参数：-XX:-UseCompressedOops</p></blockquote><p>示例：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">String</span> name<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span> age<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">boolean</span> isMale<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token doc-comment comment">/**</span>
<span class="line">*该类一个对象的大小：（假设开启了指针压缩）</span>
<span class="line">* 对象头：16 bytes</span>
<span class="line">* 实例内容： 9 bytes</span>
<span class="line">* 填充内容： 7 bytes</span>
<span class="line">* 【总共】：32 bytes = 32B = 0.032KB</span>
<span class="line">**/</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="jvm如何管理内存" tabindex="-1"><a class="header-anchor" href="#jvm如何管理内存"><span>JVM如何管理内存？</span></a></h5><p>JVM会自动回收对象。需要被回收的对象被称为“垃圾”。 对象回收又被称为“GC”； 根据回收堆里哪部分的对象，GC又分为：MinorGC（新生代）、Major GC（老年代）、Full GC（新+老）；</p><h5 id="怎么样判断对象是否可回收" tabindex="-1"><a class="header-anchor" href="#怎么样判断对象是否可回收"><span>怎么样判断对象是否可回收？</span></a></h5><p>JVM通过“可达性分析算法”，来判断对象是否需要被回收。 即维护了多个树表，根节点名为GC Root，若通过遍历GC Root的子树能找到某个对象，则认为该对象是“存活的”，无需被回收。</p><p>以下这些都可以作为GC Root：</p><ul><li>存活的线程（Thread）</li><li>Java虚拟机栈中引用的对象</li><li>方法区中静态变量引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ul><h5 id="什么是minorgc-major-gc-full-gc" tabindex="-1"><a class="header-anchor" href="#什么是minorgc-major-gc-full-gc"><span>什么是MinorGC？Major GC？Full GC？</span></a></h5><ul><li>MinorGC：清理新生代的内存，并将部分存活的对象晋升到老年代</li></ul><blockquote><p>具体方法是：将Eden区清空，将Eden区和Suvivor区中存活的对象移动到另一个Suvivor区中。将对象的年龄+1。</p></blockquote><ul><li><p>MajorGC：清理老年代的内存</p></li><li><p>FullGC：清理新生代+老年代+方法区的内存</p></li></ul><h5 id="怎么触发新生代晋升到老年代" tabindex="-1"><a class="header-anchor" href="#怎么触发新生代晋升到老年代"><span>怎么触发新生代晋升到老年代？</span></a></h5><ol><li>Eden区满，触发了MinorGC</li><li>大对象，直接进入老年代（XX:PretenureSizeThreshold）</li><li>Survivor中年龄超过一定临界值的（XX:+MaxTenuringThreshold）</li><li>Survivor区中对象占用空间的大小之和超过50%</li><li>MinorGC后对象过多，无法完全放入Survivor区，就会向老年代借用内存存放对象，以完成MinorGC</li></ol><h5 id="怎么触发gc" tabindex="-1"><a class="header-anchor" href="#怎么触发gc"><span>怎么触发GC?</span></a></h5><p>Minor GC触发条件：</p><ul><li>Eden区域满了</li><li>新生对象需要分配到新生代的Eden，当Eden区的内存不够时需要进行MinorGC</li></ul><p>Major GC触发条件：</p><ul><li>Survivor区中对象占用空间的大小之和超过50%</li></ul><p>Full GC触发条件：</p><ul><li><p>上面Minor GC时介绍中Survivor空间不足时，判断是否允许担保失败，如果不允许则进行Full GC。如果允许，并且每次晋升到老年代的对象平均大小&gt;老年代最大可用连续内存空间，也会进行Full GC。</p></li><li><p>MinorGC后存活的对象超过了老年代剩余空间</p></li><li><p>方法区内存不足时</p></li><li><p>System.gc()，可用通过-XX:+ DisableExplicitGC来禁止调用System.gc</p></li><li><p>CMS GC异常，CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，会触发Full GC</p></li></ul><h5 id="jvm如何实现gc-有哪些gc算法" tabindex="-1"><a class="header-anchor" href="#jvm如何实现gc-有哪些gc算法"><span>JVM如何实现GC？有哪些GC算法？</span></a></h5><p>默认垃圾回收器： JDK1.3之前</p><ul><li>新生代：Serial（串行的Copying算法）</li><li>老年代： Serial Old（串行的Mark-Compact算法）</li></ul><p>JDK1.8之前</p><ul><li>新生代：Parallel Scavenge（并行的Copying算法）</li><li>老年代：Serial Old（串行的Mark-Compact算法）、Parallel Old（1.8，并行的Mark-Compact算法）</li></ul><p>JDK1.9 新生代、老年代均用：G1</p><p>JDK1.11之后 ZGC</p><p><em><strong>垃圾收集器简述</strong></em></p><p><strong>Serial垃圾回收器（既有新生代的：Serial、也有老年代的Serial Old）</strong> 只使用一个GC线程进行回收（串行），会暂停所有的用户线程，不适合服务器环境。</p><p><strong>Parallel垃圾回收器（既有新生代的：ParNew、Parallel、也有老年代的：Parallel Old）</strong> 多个GC线程进行垃圾回收（并行），也会暂停所有用户线程，适用与和前台交互不强的场景，如科学计算/大数据处理等若交互场景。</p><p><em><strong>CMS垃圾回收器：老年代回收器，推荐配合ParNew使用</strong></em> 基于Mark-Sweep（“标记-清除”）算法 若干次GC后需要进行一次碎片整理。 优点：大部分时间能与用户线程并行运行。 缺点：有内存碎片，若需要为较大的对象分配内存，容易又会触发GC</p><p>过程：</p><ul><li>初始标记(CMS-initial-mark) ,会导致stw;</li><li>并发标记(CMS-concurrent-mark)，与用户线程同时运行；</li><li>预清理（CMS-concurrent-preclean），与用户线程同时运行；</li><li>可被终止的预清理（CMS-concurrent-abortable-preclean） 与用户线程同时运行；</li><li>重新标记(CMS-remark) ，会导致stw；</li><li>并发清除(CMS-concurrent-sweep)，与用户线程同时运行；</li><li>并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行。</li></ul><p><em><strong>G1垃圾回收器</strong></em> 基于Mark-Compact（“标记-整理”）算法 优点：回收得到的内存空间是连续的。</p><p>过程： Eden区满，触发Minor GC：回收新生代； Full GC：回收新生代、老年代、永久代（JDK1.8后为metaspace）</p><p><strong>一般的垃圾回收器搭配&amp;如何选择垃圾回收器</strong></p><ol><li><p>串行收集器：Serial（yong区）+ SerialOld（old区） 对应参数： -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseSerialGC</p><blockquote><p>最古老的垃圾收集器，单个GC线程，GC时会阻塞用户线程。 适合：单核CPU或者小内存，单机程序</p></blockquote></li><li><p>并行收集器：ParNew（Yong） + SerialOld（old）<strong>（已被废弃）</strong> 对应参数： -XX:+UseParNewGC</p><blockquote><p>很多java虚拟机运行在server模式下新生代的默认垃圾收集器。 多线程GC，但仍然会阻塞用户线程。</p></blockquote></li><li><p>并行收集器：ParallelScavenge（Young） + ParallelOld（old） 对应参数： -XX:+UseParallelGC（同时会激活-XX:+UseParallelOldGC参数）</p><blockquote><p>ParallelScavenge提供了一种自适应调整策略，会收集系统性能监控信息，尽量让GC时间占JVM运行时间越少，提高系统吞吐量。 吞吐量=用户线程运行时间/（GC线程运行时间 + 用户线程运行时间） 适合：多CPU，后台计算型应用</p></blockquote></li><li><p>并发标记清除收集器：CMS <strong>（1.9后被废除）</strong> 对应参数： -XX:+UseConcMarkSweepGC（同时会激活-XX:+UseParNewGC参数）</p><blockquote><p>是一种以获取最短回收停顿时间为目的的收集器。适用于互联网站或者B/S系统的服务器上。 ParNew（yong）+CMS（Old）+SerialOld收集器的组合，Serial Old将作为CMS出错的后备收集器。 适合：多CPU，追求低停顿时间，快速响应如互联网应用 jdk1.7或更低、jdk8内存较低（低于4G）时可选择CMS。</p></blockquote></li><li><p>G1收集器 对应参数： -XX:+UseG1GC</p><blockquote><p>从1.7版本之后就开始有的垃圾回收器。 G1意为“Garbage First”，即垃圾优先，哪一块垃圾多先清理那一块。 特点为：并发并行（）、没有内存碎片（基于标记整理算法）、可预测的停顿（STW） 适合：内存较大（8G以上）、多CPU的服务器</p></blockquote></li></ol><h6 id="垃圾回收算法简述" tabindex="-1"><a class="header-anchor" href="#垃圾回收算法简述"><span>垃圾回收算法简述</span></a></h6><p><em><strong>Copying（标记复制）算法：新生代的算法</strong></em> 将内存分为大小相等的两份（即现在的Eden区和Survivor区） 1.Eden区满后，触发一次GC：标记Eden区的存活对象，将存活对象移至其中一个Survivor区（Survivor0） 2.清空Eden区 3.Eden区又满，触发一次GC：标记Eden区及Survivor区的存活对象，将存活对象移至另一个Survivor区（Survivor1） 4.清空Eden区和Survivor0区 5.若存活对象经历GC的次数达到一个阙值（-XX:MaxTenuringThreshold），则会被移进老年代</p><p>优点：无需清除和整理、效率较高；不会产生内存碎片。适合会有大量失活的新生代 缺点：需要两倍的内存空间</p><p><em><strong>Mark-Sweep（“标记-清除”）算法：老年代的算法</strong></em></p><ol><li>标记需要清除的对象</li><li>清除</li></ol><p>优点：快速简单 缺点：有内存碎片，若需要为较大的对象分配内存，容易又会触发GC</p><p><em><strong>Mark-Compact（“标记-整理”）算法：老年代的算法</strong></em></p><ol><li>标记需要清除的对象</li><li>让存活对象移至一端</li><li>清除</li></ol><h5 id="与垃圾回收相关的系统参数" tabindex="-1"><a class="header-anchor" href="#与垃圾回收相关的系统参数"><span>与垃圾回收相关的系统参数</span></a></h5><p>-XX:+MaxTenuringThreshold =15 晋升到老年代需要的年龄</p><p>-XX:TargetSurvivorRatio =50% Survivor空间占用超过50%，会将年龄较大的晋升到老年代</p><p>-XX:NewRatio=1:2 新生代与老年代的比例（默认1:2）</p><p>-XX:SurvivorRatio=8:1:1 Eden区与Survivor区的比例（默认8:1:1）</p><p>-XX:PretenureSizeThreshold= 对象大于此参数的值，则绕过新生代，直接分配到老年代（只对Serial及ParNew有效）</p><p>-Xms —— 堆的初始大小（young+old+perm）</p><p>-Xmx —— 最大堆内存</p><p>-Xmn —— 年轻代大小（young，推荐配置为整个堆的3/8）</p><p>-XX:NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小（young，默认young:old=1:2）</p><p>-XX：MaxPermSize —— 最大方法区内存（perm，1.8之后该参数无效，因为metaspace无限大）</p><h6 id="开启垃圾回收器类的参数" tabindex="-1"><a class="header-anchor" href="#开启垃圾回收器类的参数"><span>开启垃圾回收器类的参数</span></a></h6><p>-XX:+UseSerialGC （新生代用：Serial 老年代用：Serial Old）</p><p>-XX:+UseParNewGC（新生代用：ParNew 老年代默认用：Serial Old）</p><p>-XX:+UseParallelGC（新生代用：Parallel Scavenge 老年代默认用：Serial Old(1.8前)、Parallel Old(1.8后)）</p><p>-XX:+UseParallelOldGC（老年代用：Parallel Old，新生代：自动激活-XX:+UseParallelGC使用）</p><p>-XX:+UseConcMarkSweepGC （老年代用：CMS，新生代：自动激活-XX:+UseParNewGC使用）</p><p>-XX:+UseG1GC （新生代用：G1 老年代用：G1）</p><h5 id="其他常用参数" tabindex="-1"><a class="header-anchor" href="#其他常用参数"><span>其他常用参数</span></a></h5><p>-XX:InitialHeapSize 初始堆大小（与Xms一样）</p><p>-XX:MaxHeapSize 最大堆大小（与Xmx一样）</p><p>-Xss 每个线程的堆栈大小</p><p>-XX:+HeapDumpOnOutOfMemoryError JVM发送OOM时，自动生成Dump文件（内存快照）</p><p>-XX:HeapDumpPath=$1_dump.hprof Dump文件路径</p><p>-XX:+PrintGCDetails 打印GC日志</p><p>-XX:+PrintGCDateStamps 打印GC日志时间</p><p>-Xloggc:$1_gc_trace.log GC日志路径</p><h5 id="jvm启动参数" tabindex="-1"><a class="header-anchor" href="#jvm启动参数"><span>JVM启动参数</span></a></h5><p>可以通过“java -Dxxx=xxx&quot;设置JVM启动参数。示例：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token function">java</span> <span class="token parameter variable">-Dname</span><span class="token operator">=</span>Joe <span class="token parameter variable">-version</span> </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>启动参数分为三类：</p><ul><li>标准参数（-）：所有JVM必须实现，向后兼容； <ul><li>-version</li><li>-classpath</li><li>-server</li><li>...</li></ul><blockquote><p>可以通过在cmd中输入 “java -help” 查看有哪些标准参数</p></blockquote></li><li>非标准参数（-X）：默认JVM有实现，但其他JVM不一定实现，不一定向后兼容； <ul><li>-Xmn</li><li>-Xmx</li><li>-Xloggc:filename</li></ul><blockquote><p>可以通过在cmd中输入 “java -X” 查看有哪些非标准参数</p></blockquote></li><li>非Stable参数（-XX）</li></ul><h5 id="类加载过程" tabindex="-1"><a class="header-anchor" href="#类加载过程"><span>类加载过程</span></a></h5><p>类加载过程</p><ol><li>查找.class文件</li></ol><ul><li>Bootstrap ClassLoader 从JAVA_HOME/lib根据全类名查</li><li>ExtClassLoader（继承Classloader） 从JAVA_HOME/lib/ext根据全类名查</li><li>AppClassLoader（继承ExtClassLoader） 从项目Classpath根据全类名查</li></ul><ol start="2"><li>解析.class(二进制)，将.class的信息保存在方法区</li><li>生成一个Class对象，保存在对象实例池</li><li>在方法区，为类的静态变量分配空间（赋默认值：0,null,0L,false）</li><li>初始化执行，顺序如下： <ul><li>静态变量、静态代码块（先执行父类，若在同一个类，则按顺序执行）</li><li>成员变量、成员代码块（先执行父类，若在同一个类，则按顺序执行）</li><li>构造器（先执行父类，若在同一个类，则按顺序执行）</li></ul></li></ol><h3 id="jvm调优操作" tabindex="-1"><a class="header-anchor" href="#jvm调优操作"><span>JVM调优操作</span></a></h3><p>参考：<a href="https://blog.csdn.net/weixin_43238110/article/details/93793357" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/weixin_43238110/article/details/93793357</a></p><p><strong>调优的目的</strong></p><ol><li>尽量减少Full GC的频率</li></ol><p><strong>调优手段</strong></p><ol><li>配置更多/更少的内存给JVM（配置Xmx）</li><li>若经常发生FullGC，则可以配置更大的老年代内存（配置XX:NewRatio，老年代越大，新生代Gc越频繁，但Full GC频率越少）</li><li>线程堆栈的设置（默认为1M，可设置位256K）</li></ol><p><strong>查看JVM参数</strong></p><p>查看默认参数：（初始堆大小、最大堆大小、使用哪种垃圾回收器、JVM版本等）</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token function">java</span> <span class="token parameter variable">-XX:+PrintCommandLineFlags</span> <span class="token parameter variable">-version</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>查看所有参数：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token comment">#方法1</span></span>
<span class="line"><span class="token function">java</span> <span class="token parameter variable">-XX:+PrintFlagsFinal</span> <span class="token parameter variable">-version</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">#方法2</span></span>
<span class="line">jinfo <span class="token parameter variable">-flags</span> <span class="token punctuation">[</span>pid<span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看某个JVM参数：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token comment">#查看所有包含GC字段的JVM参数</span></span>
<span class="line"><span class="token function">java</span> <span class="token parameter variable">-XX:+PrintFlagsFinal</span> -version<span class="token operator">|</span><span class="token function">grep</span> GC</span>
<span class="line"></span>
<span class="line"><span class="token comment">#查看所有包含Size字段的JVM参数</span></span>
<span class="line"><span class="token function">java</span> <span class="token parameter variable">-XX:+PrintFlagsFinal</span> -version<span class="token operator">|</span><span class="token function">grep</span> Size</span>
<span class="line"></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>查看JVM情况</strong></p><p>jmap -heap pid：输出堆内存设置和使用情况（JDK11使用jhsdb jmap --heap --pid pid）</p><p>jmap -histo pid：输出所有实例对象在堆中的占比</p><p>查看内存使用情况、GC情况：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token operator">&gt;</span> jstat <span class="token parameter variable">-gc</span> <span class="token punctuation">[</span>pid<span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span>
<span class="line"><span class="token number">28672.0</span> <span class="token number">28672.0</span> <span class="token number">15921.7</span>  <span class="token number">0.0</span>   <span class="token number">29696.0</span>   <span class="token number">2233.7</span>   <span class="token number">65536.0</span>    <span class="token number">47813.5</span>   <span class="token number">57856.0</span> <span class="token number">54674.3</span> <span class="token number">8960.0</span> <span class="token number">7947.5</span>     <span class="token number">40</span>    <span class="token number">0.114</span>   <span class="token number">4</span>      <span class="token number">0.166</span>    <span class="token number">0.279</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>S0C</th><th>S1C</th><th>S0U</th><th>S1U</th><th>EC</th><th>EU</th><th>OC</th><th>OU</th><th>MC</th><th>MU</th><th>CCSC</th><th>CCSU</th><th>YGC</th><th>YGCT</th><th>FGC</th><th>FGCT</th><th>GCT</th></tr></thead><tbody><tr><td>Suvivor0区容量</td><td>Suvivor1区容量</td><td>Suvivor0区使用量</td><td>Suvivor1区使用量</td><td>Eden区容量</td><td>Eden区使用量</td><td>Old区容量</td><td>Old区使用量</td><td>Metaspace容量</td><td>Metaspace使用量</td><td>压缩类空间大小</td><td>压缩类空间使用率</td><td>Young GC次数</td><td>Young GC时间</td><td>Old GC次数</td><td>Old GC时间</td><td>总GC时间</td></tr><tr><td>28672.0</td><td>28672.0</td><td>15921.7</td><td>0.0</td><td>29696.0</td><td>2233.7</td><td>65536.0</td><td>47813.5</td><td>57856.0</td><td>54674.3</td><td>8960.0</td><td>7947.5</td><td>40</td><td>0.114</td><td>4</td><td>0.166</td><td>0.279</td></tr></tbody></table><p>查看内存使用率：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token operator">&gt;</span> jstat <span class="token parameter variable">-gcutil</span> <span class="token punctuation">[</span>pid<span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span>
<span class="line">  <span class="token number">0.00</span>  <span class="token number">98.78</span>  <span class="token number">15.75</span>  <span class="token number">75.47</span>  <span class="token number">94.12</span>  <span class="token number">88.70</span>     <span class="token number">83</span>    <span class="token number">0.192</span>     <span class="token number">4</span>    <span class="token number">0.166</span>    <span class="token number">0.357</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>S0</th><th>S1</th><th>E</th><th>O</th><th>M</th><th>CCS</th><th>YGC</th><th>YGCT</th><th>FGC</th><th>FGCT</th><th>GCT</th></tr></thead><tbody><tr><td>Suvivor0使用率</td><td>Suvivor1使用率</td><td>Eden使用率</td><td>Old使用率</td><td>Metaspace使用率</td><td>压缩类空间使用率</td><td>Young GC次数</td><td>Young GC时间</td><td>Old GC次数</td><td>Old GC时间</td><td>总GC时间</td></tr><tr><td>0.00</td><td>98.78</td><td>15.75</td><td>75.47</td><td>94.12</td><td>88.70</td><td>83</td><td>0.192</td><td>4</td><td>0.166</td><td>0.357</td></tr></tbody></table><p><strong>查看DUMP文件</strong></p><ol><li>主动型</li></ol><ul><li>首先通过top命令获取到jvm的pid</li><li>使用jmap命令生成dump文件</li></ul><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token comment">#test.dump为dump文件名，1246为jvm的pid，这些都根据实际情况来传参</span></span>
<span class="line">jmap <span class="token parameter variable">-dump:format</span><span class="token operator">=</span>b,file<span class="token operator">=</span>test.dump <span class="token number">1246</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>进入java/bin目录下，打开jvisualvm工具。选择 文件-&gt;装入，将文件类型改为堆Dump，选择test.dump文件即可。</li><li>也可以选择jprofile工具（需要下载）</li></ul><ol start="2"><li>被动型</li></ol><ul><li>当JVM内存溢出时，会自动生成dump文件。（需要-XX:+HeapDumpOnOutOfMemoryError该参数打开）</li></ul><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token comment">#查看dump文件生成位置</span></span>
<span class="line"><span class="token function">java</span> <span class="token parameter variable">-XX:+PrintFlagsInitial</span> <span class="token operator">|</span> findstr HeapDumpPath</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>取到dump文件后，通过jvisualvm工具分析即可。</li></ul><p><strong>查看GC情况</strong></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token comment">#设置打印GC日志</span></span>
<span class="line"><span class="token parameter variable">-XX:+PrintGCDetails</span></span>
<span class="line"><span class="token comment">#设置打印GC日志时间</span></span>
<span class="line"><span class="token parameter variable">-XX:+PrintGCTimeStamps</span></span>
<span class="line"><span class="token comment">#设置GC日志文件位置（输出到gc.log）</span></span>
<span class="line"><span class="token parameter variable">-Xloggc:gc.log</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>触发GC后，便会看到日志中有类似如下内容：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token comment">#日志开头，是JVM的启动参数</span></span>
<span class="line">CommandLine flags: <span class="token parameter variable">-XX:InitialHeapSize</span><span class="token operator">=</span><span class="token number">10485760</span> <span class="token parameter variable">-XX:MaxHeapSize</span><span class="token operator">=</span><span class="token number">10485760</span> <span class="token parameter variable">-XX:MaxNewSize</span><span class="token operator">=</span><span class="token number">5242880</span> <span class="token parameter variable">-XX:NewSize</span><span class="token operator">=</span><span class="token number">5242880</span> <span class="token parameter variable">-XX:OldPLABSize</span><span class="token operator">=</span><span class="token number">16</span> </span>
<span class="line"><span class="token parameter variable">-XX:PretenureSizeThreshold</span><span class="token operator">=</span><span class="token number">10485760</span> <span class="token parameter variable">-XX:+PrintGC</span> <span class="token parameter variable">-XX:+PrintGCDetails</span> <span class="token parameter variable">-XX:+PrintGCTimeStamps</span> <span class="token parameter variable">-XX:SurvivorRatio</span><span class="token operator">=</span><span class="token number">8</span> <span class="token parameter variable">-XX:+UseCompressedClassPointers</span> </span>
<span class="line"><span class="token parameter variable">-XX:+UseCompressedOops</span> <span class="token parameter variable">-XX:+UseConcMarkSweepGC</span> <span class="token parameter variable">-XX:-UseLargePagesIndividualAllocation</span> <span class="token parameter variable">-XX:+UseParNewGC</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">#在JVM启动后的0.383秒，发生了第一次GC，原因是Allocation Failure，即给对象分配内存时内存不足</span></span>
<span class="line"><span class="token comment">#此时使用了ParNew收集器进行young GC</span></span>
<span class="line"><span class="token comment">#gc后，新生代占用内存由 3543K 变为 512K，新生代总内存为4608K；</span></span>
<span class="line"><span class="token comment">#gc后，堆占用内存由 3543K 变为 1828K，堆总内存为9728K；</span></span>
<span class="line"><span class="token number">0.383</span>: <span class="token punctuation">[</span>GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span> <span class="token number">0.384</span>: <span class="token punctuation">[</span>ParNew: 3543K-<span class="token operator">&gt;</span>512K<span class="token punctuation">(</span>4608K<span class="token punctuation">)</span>, <span class="token number">0.0024598</span> secs<span class="token punctuation">]</span> 3543K-<span class="token operator">&gt;</span>1828K<span class="token punctuation">(</span>9728K<span class="token punctuation">)</span>, <span class="token number">0.0026607</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Times: <span class="token assign-left variable">user</span><span class="token operator">=</span><span class="token number">0.00</span> <span class="token assign-left variable">sys</span><span class="token operator">=</span><span class="token number">0.00</span>, <span class="token assign-left variable">real</span><span class="token operator">=</span><span class="token number">0.00</span> secs<span class="token punctuation">]</span></span>
<span class="line"><span class="token comment">#又一次GC</span></span>
<span class="line"><span class="token comment">#gc后，新生代占用内存由 2627K 变为 0K，新生代总内存为4608K；</span></span>
<span class="line"><span class="token comment">#gc后，堆占用内存由 3943K 变为 1828K，堆总内存为9728K；</span></span>
<span class="line"><span class="token number">0.386</span>: <span class="token punctuation">[</span>GC <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span> <span class="token number">0.387</span>: <span class="token punctuation">[</span>ParNew: 2627K-<span class="token operator">&gt;</span>0K<span class="token punctuation">(</span>4608K<span class="token punctuation">)</span>, <span class="token number">0.0015255</span> secs<span class="token punctuation">]</span> 3943K-<span class="token operator">&gt;</span>1828K<span class="token punctuation">(</span>9728K<span class="token punctuation">)</span>, <span class="token number">0.0015985</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Times: <span class="token assign-left variable">user</span><span class="token operator">=</span><span class="token number">0.00</span> <span class="token assign-left variable">sys</span><span class="token operator">=</span><span class="token number">0.00</span>, <span class="token assign-left variable">real</span><span class="token operator">=</span><span class="token number">0.00</span> secs<span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">#堆内存使用快照</span></span>
<span class="line">Heap</span>
<span class="line"> par new generation   total 4608K, used 2089K <span class="token punctuation">[</span>0x00000000ff600000, 0x00000000ffb00000, 0x00000000ffb00000<span class="token punctuation">)</span></span>
<span class="line">  eden space 4096K,  <span class="token number">51</span>% used <span class="token punctuation">[</span>0x00000000ff600000, 0x00000000ff80a558, 0x00000000ffa00000<span class="token punctuation">)</span></span>
<span class="line">  from space 512K,   <span class="token number">0</span>% used <span class="token punctuation">[</span>0x00000000ffa00000, 0x00000000ffa00000, 0x00000000ffa80000<span class="token punctuation">)</span></span>
<span class="line">  to   space 512K,   <span class="token number">0</span>% used <span class="token punctuation">[</span>0x00000000ffa80000, 0x00000000ffa80000, 0x00000000ffb00000<span class="token punctuation">)</span></span>
<span class="line"> concurrent mark-sweep generation total 5120K, used 1828K <span class="token punctuation">[</span>0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000<span class="token punctuation">)</span></span>
<span class="line"> Metaspace       used 3101K, capacity 4620K, committed 4864K, reserved 1056768K</span>
<span class="line">  class space    used 327K, capacity 392K, committed 512K, reserved 1048576K</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>查看当前启用的垃圾回收器类型</strong></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token comment">#查看所有JVM参数</span></span>
<span class="line"><span class="token function">java</span> <span class="token parameter variable">-XX:+PrintFlagsInitial</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">#查看当前使用的垃圾回收器</span></span>
<span class="line"><span class="token function">java</span> <span class="token parameter variable">-XX:+PrintCommandLineFlags</span> <span class="token parameter variable">-version</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">#查看垃圾回收器启用情况</span></span>
<span class="line"><span class="token function">java</span> -XX:+PrintFlagsInitial<span class="token operator">|</span>findstr Use.*GC</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,132)]))}const o=s(i,[["render",p]]),c=JSON.parse('{"path":"/java/jvm/","title":"JVM","lang":"en-US","frontmatter":{"title":"JVM"},"git":{"updatedTime":1747636056000,"contributors":[{"name":"azil","username":"azil","email":"854257920@qq.com","commits":2,"url":"https://github.com/azil"},{"name":"dongyz8","username":"dongyz8","email":"dongyz8@gdii-yueyun.com","commits":5,"url":"https://github.com/dongyz8"}],"changelog":[{"hash":"f0a3a489e545221881ab4bd79bd0d1f8c8151c6d","time":1747636056000,"email":"dongyz8@gdii-yueyun.com","author":"dongyz8","message":"commit"},{"hash":"c97979e28496bfd6a49b98c58b764b3950f0de75","time":1739849131000,"email":"dongyz8@gdii-yueyun.com","author":"dongyz8","message":"commit"},{"hash":"3a17e00bef3e15a50b0ac0ff48255d9c04fb141a","time":1700032761000,"email":"dongyz8@gdii-yueyun.com","author":"dongyz8","message":"commit"},{"hash":"c134bd6d46aca8a064a19bb65704fbff919268a4","time":1690885984000,"email":"dongyz8@gdii-yueyun.com","author":"dongyz8","message":"commit"},{"hash":"ba56277d160fbccaf0ee5c13019cdd9ebdcf438f","time":1689858036000,"email":"854257920@qq.com","author":"azil","message":"commit"},{"hash":"70b37d4f176375118b0ae99f54befb1f90908112","time":1689762909000,"email":"dongyz8@gdii-yueyun.com","author":"dongyz8","message":"commit"},{"hash":"30d5f2d518aad6bb98f35c66e1d957434a1a6467","time":1689514348000,"email":"854257920@qq.com","author":"azil","message":"commit"}]},"filePathRelative":"java/jvm/README.md"}');export{o as comp,c as data};
