---
title: 并发实战
---


# 并发实战


## CompletableFuture

```java
    public static void main(String[] args) throws Exception{
        // 方式1: 使用runAsync执行没有返回值的任务
        {
            CompletableFuture<Void> future1 = CompletableFuture.runAsync(() -> {
                //...
            });
            // 阻塞等待结果
            future1.get();
        }

        // 方式2: 使用supplyAsync执行有返回值的任务
        {
            CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {
                return "异步任务2的结果";
            });
            // 阻塞等待结果
            String result = future2.get();
            System.out.println("获取到结果: " + result);
        }

        //3. 链式调用
        {
            CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> {
                return "Hello";
            }).thenApply(e->{
                return e +" World";
            }).thenAccept(e->{
                System.out.println(e);
            });
            // 阻塞等待结果
            future.get();
        }

        //4. 组合2个Future
        {
            CompletableFuture<String> userInfoFuture = CompletableFuture.supplyAsync(() -> {
                System.out.println("开始获取用户基本信息...");
                return "张三";
            });
            CompletableFuture<String> userOrderFuture = CompletableFuture.supplyAsync(() -> {
                System.out.println("开始获取用户订单信息...");
                return "订单列表";
            });
            // 合并两个结果
            CompletableFuture<String> combinedFuture = userInfoFuture.thenCombine(userOrderFuture,
                    (userInfo, orderInfo) -> {
                        System.out.println("合并用户信息和订单信息...");
                        return "用户: " + userInfo + ", 订单: " + orderInfo;
                    });
            System.out.println("合并结果: " + combinedFuture.get());
        }

        //5. 等待所有Future完成
        {
            CompletableFuture<String> task1 = CompletableFuture.supplyAsync(() -> {
                return "任务1完成";
            });
            CompletableFuture<String> task2 = CompletableFuture.supplyAsync(() -> {
                return "任务2完成";
            });
            CompletableFuture<String> task3 = CompletableFuture.supplyAsync(() -> {
                return "任务3完成";
            });
            // 等待所有任务完成
            CompletableFuture<Void> allTasks = CompletableFuture.allOf(task1, task2, task3);
            // 当所有任务完成后执行的操作
            CompletableFuture<String> finalResult = allTasks.thenApply(v -> {
                // 获取各个任务的结果
                String result1 = task1.join(); // 使用join而不是get，避免检查异常
                String result2 = task2.join();
                String result3 = task3.join();
                return "所有任务完成: " + Arrays.asList(result1, result2, result3);
            });
            System.out.println(finalResult.get());
        }

        //6. 实际示例
        {
            // 1. 获取用户ID列表
            CompletableFuture<List<Integer>> userIdsFuture = CompletableFuture.supplyAsync(()->{
                List<Integer> result = null;
                //...
                return result;
            });

            // 2. 获取所有用户详情（并行查询，thenCompose:类似flatMap()）
            CompletableFuture<List<String>> allUserDetailsFuture = userIdsFuture.thenCompose(userIds -> {
                // 为每个用户创建异步查询任务
                List<CompletableFuture<String>> userDetailFutures = userIds.stream()
                        .map(id-> CompletableFuture.supplyAsync(()->{
                            //获取用户信息逻辑...
                            return "";
                        })).collect(Collectors.toList());

                // 等待所有用户详情查询完成
                CompletableFuture<Void> allFutures = CompletableFuture.allOf(
                        userDetailFutures.toArray(new CompletableFuture[0])
                );

                // 收集所有结果
                return allFutures.thenApply(v ->
                        userDetailFutures.stream()
                                .map(CompletableFuture::join)
                                .collect(Collectors.toList())
                );
            });
        }

        //7. 等待任意一个完成
        {
            // 模拟多个数据源查询
            CompletableFuture<String> dataSource1 = CompletableFuture.supplyAsync(() -> {
                return "数据源1的结果";
            });
            CompletableFuture<String> dataSource2 = CompletableFuture.supplyAsync(() -> {
                return "数据源2的结果";
            });
            CompletableFuture<String> dataSource3 = CompletableFuture.supplyAsync(() -> {
                return "数据源3的结果";
            });
            // 获取最先完成的结果
            CompletableFuture<Object> firstCompleted = CompletableFuture.anyOf(
                    dataSource1, dataSource2, dataSource3);
            System.out.println("最先返回的结果: " + firstCompleted.get());
        }

        //8. 异常处理
        {
            // 模拟可能抛出异常的任务
            CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
                System.out.println("开始执行任务...");
                if (Math.random() > 0.5) {
                    throw new RuntimeException("任务执行失败!");
                }
                return "任务成功完成";
            });

            // 异常处理方式1: exceptionally - 类似于catch
            CompletableFuture<String> handledFuture = future.exceptionally(ex -> {
                System.out.println("发生异常: " + ex.getMessage());
                return "默认结果";
            });

            // 异常处理方式2: handle - 同时处理正常结果和异常
            CompletableFuture<String> handledFuture2 = future.handle((result, ex) -> {
                if (ex != null) {
                    System.out.println("处理异常: " + ex.getMessage());
                    return "异常处理后的默认结果";
                }
                return "处理后的结果: " + result;
            });

            // 异常处理方式3: whenComplete - 类似finally，不改变结果
            CompletableFuture<String> whenCompleteFuture = future.whenComplete((result, ex) -> {
                if (ex != null) {
                    System.out.println("任务执行出现异常: " + ex.getMessage());
                } else {
                    System.out.println("任务正常完成: " + result);
                }
            });

            try {
                System.out.println("结果: " + handledFuture.get());
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        //9. 自定义线程池
        {
            // 创建自定义线程池
            ExecutorService threadPool = Executors.newFixedThreadPool(5);
            // 任务1
            CompletableFuture.supplyAsync(()->{
                System.out.println("任务1执行线程: " + Thread.currentThread().getName());
                return "结果1";
            },threadPool);

            // 任务2
            CompletableFuture.supplyAsync(()->{
                System.out.println("任务2执行线程: " + Thread.currentThread().getName());
                return "结果2";
            },threadPool);
        }

    }
```

## RxJava

