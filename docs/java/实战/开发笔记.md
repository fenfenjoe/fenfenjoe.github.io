---
title: 开发笔记
---

# 开发笔记


## 1.导出百万行的Excel

略

## 2. 异步/多线程 的多种写法

### JDK1.8之前

> [!note]
> 异步执行：直接新建一个Thread对象

```java
public class Test{
    public static void one(){

        Thread thread = new Thread(){
            @Override
            public void run() {
                try {
                    //停留1s，展示异步执行成功
                    Thread.sleep(1000);
                    System.out.println("线程ID："+Thread.currentThread().getId()+"  输出：haha");
                    //
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        };
        thread.start();
        System.out.println("线程ID："+Thread.currentThread().getId()+"  输出：heihei");
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
```


> [!note] 
> 异步执行：新建1个Runnable对象，放到线程池执行

```java
public class Test{
    public static void two(){
        //定义一个任务
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                //停留1s，展示异步执行成功
                try {
                    Thread.sleep(1000);
                    System.out.println("线程ID："+Thread.currentThread().getId()+"  输出：haha");
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        };
        //定义一个线程池
        ExecutorService threadPool = Executors.newFixedThreadPool(1);
        threadPool.execute(runnable);
        System.out.println("线程ID："+Thread.currentThread().getId()+"  输出：heihei");
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        //记得关闭线程池
        threadPool.shutdown();
    }
    
}
```

> [!note]
> 多线程执行：新建N个Runnable对象，放到线程池执行

```java
public class Test{
    public static void three() {
        //需要定义：
        // 1个计数器（CountDownLatch）
        // 1个线程池（ExecutorService）
        // 10个无返回值的任务（Runnable）

        int TASK_NUM = 10;
        //计数器
        CountDownLatch cdl = new CountDownLatch(TASK_NUM);
        //定义10个任务
        List<Runnable> taskList = new ArrayList<>();
        for(int i=0;i<TASK_NUM;i++){
            int finalNum = i;
            taskList.add(() -> {
                try {
                    Thread.sleep(finalNum * 1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println("==========执行完毕！" + finalNum);
                cdl.countDown();
            });
        }
        //多线程执行任务
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        for(Runnable task:taskList){
            threadPool.execute(task);
        }
        //等待所有任务执行完毕
        System.out.println("==========wait!");
        try {
            cdl.await();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        //最后记得关闭线程池
        threadPool.shutdown();
        System.out.println("==========finish!");
    }
}
```


> [!note]
> 多线程执行&有返回值：新建N个FutureTask对象，放到线程池执行

```java
public class Test{
    public static void four() {
        //需要定义：
        // 1个计数器（CountDownLatch）
        // 1个线程池（ExecutorService）
        // 10个有返回值的任务（FutureTask + Callable）


        int TASK_NUM = 10;
        //计数器
        CountDownLatch cdl = new CountDownLatch(TASK_NUM);
        //定义10个任务
        List<FutureTask<Integer>> taskList = new ArrayList<>();
        for(int i=0;i<TASK_NUM;i++){
            int finalNum = i;
            taskList.add(new FutureTask<>(() -> {
                try {
                    Thread.sleep(finalNum * 1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println("==========执行完毕！" + finalNum);
                cdl.countDown();
                return finalNum;
            }));
        }
        //多线程执行任务
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        for(FutureTask task:taskList){
            threadPool.execute(task);
        }
        //等待所有任务执行完毕
        System.out.println("==========wait!");
        try {
            cdl.await();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        //取出计算结果并汇总。这里只是简单地求和。
        int sum = 0;
        for(FutureTask<Integer> task:taskList){
            try {
                sum+=task.get();
            } catch (Exception e) {
                throw new RuntimeException(e);
            } 
        }
        System.out.println("==========result:"+sum);
        //最后记得关闭线程池
        threadPool.shutdown();
        System.out.println("==========finish!");
    }
}
```

> [!note]
> 多线程执行&有返回值2：无需计数器

```java
public class Test{
    public static void five() {
        //需要定义：
        // 不用计数器（CountDownLatch）
        // 1个线程池（CompletionService代替ExecutorService）
        // 10个有返回值的任务（Callable）
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        CompletionService<Integer> cService = new ExecutorCompletionService<Integer>(threadPool);
        int TASK_NUM = 10;
        //定义10个任务
        List<Callable<Integer>> taskList = new ArrayList<>();
        for(int i=0;i<TASK_NUM;i++){
            int finalNum = i;
            taskList.add(() -> {
                return finalNum;
            });
        }

        //执行任务
        for(Callable task:taskList){
            cService.submit(task);
        }

        //不用等到所有任务出结果才汇总
        //先计算出结果的就可以先汇总
        int sum = 0;
        for(int i=0;i<TASK_NUM;i++){
            try {
                int result = cService.take().get();
                System.out.println("==========执行完毕！" + result);
                sum+= result;
            } catch (Exception e) {
                throw new RuntimeException(e);
            } 
        }
        System.out.println("==========result:"+sum);
        //最后记得关闭线程池
        threadPool.shutdown();
        System.out.println("==========finish!");
    }
}
```

### JDK1.8后

> [!note]
> 异步执行，可使用CompletableFuture类来执行异步方法。写法简单

```java
public class Test{
    public static void one(){
        //开启一个线程
        CompletableFuture<Void> future = CompletableFuture.runAsync(()->{
            System.out.println("线程ID："+Thread.currentThread().getId()+"  输出：haha");
        });
        System.out.println("线程ID："+Thread.currentThread().getId()+"  输出：heihei");
        future.join();
    }
}
```


> [!note]
> 多线程执行&有返回值

```java
public class Test{
    public static void two() {
        //需要定义：
        // 不用计数器（CountDownLatch）
        // 不用线程池（CompletableFuture自带线程池(ForkJoinPool.commonPool())）
        // 10个有返回值的任务（Callable）
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        int TASK_NUM = 10;
        //定义10个任务
        AtomicInteger sum = new AtomicInteger();
        List<CompletableFuture<Integer>> taskList = new ArrayList<>();
        for(int i=0;i<TASK_NUM;i++){
            int finalNum = i;
            //执行任务
            taskList.add(CompletableFuture.supplyAsync(() -> {
                try {
                    Thread.sleep(finalNum * 1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println("线程ID："+Thread.currentThread().getId()+"==========执行完毕！结果：" + finalNum);
                return finalNum;
            }).thenApply(sum::addAndGet));
        }


        System.out.println("==========等待汇总结果！");
        CompletableFuture
                .allOf(taskList.toArray(new CompletableFuture[taskList.size()]))
                .join();
        System.out.println("==========result:"+sum);
        //最后记得关闭线程池
        threadPool.shutdown();
        System.out.println("==========finish!");
    }
}
```

## 3. 手工开启数据库事务

```java
@Service
@Slf4j
public class TestServiceImpl implements TestService{
    @Autowired
    private TransactionTemplate transactionTemplate;
    
    @Autowired
    private StudentMapper studentMapper;

    @Autowired
    private TeacherMapper teacherMapper;
    
    public void test(List<StudentDto> studentDtoList,List<TeacherDto> teacherDtoList){
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
                try{
                    studentMapper.batchInsert(studentDtoList);
                    teacherMapper.batchInsert(teacherDtoList);
                }catch (Exception e){
                    log.error("保存报错",e);
                    transactionStatus.setRollbackOnly();
                }
            }
        });
    }
}

```

## 4. LocalDate、LocalTime、LocalDateTime的使用

| 日期时间类         | 说明        |
|---------------|-----------|
| LocalDate     | 只包含年月日    |
| LocalTime     | 只包含时分秒    |
| LocalDateTime | 包含年月日、时分秒 |

* 获取年月日、时分秒
```java
LocalDate now = LocalDate.now(); //获取当前的年月日
System.out.println(now); //2024-05-28
System.out.println(now.getYear()); //2024
System.out.println(nowdata.getMonth().getValue());//4 获取当前月份
System.out.println(nowdata.getDayOfMonth());//6 获取今天几号
System.out.println(nowdata.getDayOfWeek().getValue());//2 获取今天星期几
System.out.println(nowdata.getDayOfYear());//96 获取今天是今年的第几天

LocalTime nowTime = LocalTime.now();
System.out.println(nowTime);//09:51:11.987 获取当前的时间
System.out.println(nowTime.getHour());//9 获取当前时间的小时
System.out.println(nowTime.getMinute());//51 获取当前时间的分钟
System.out.println(nowTime.getSecond());//11 获取当前时间的秒
```

## 5. Map <--> Object 转换示例代码

```
// Map 转 Bean
cn.hutool.core.bean.BeanUtil.mapToBean(map,StudentDto.class,false,null);

// Bean 转 Map
cn.hutool.core.bean.BeanUtil.beanToMap(studentDto);
```

## 6. Java8 Stream Collectors的常见用法



## 7. Java8 Stream Comparator的常见用法

```
//对person List进行排序
//先根据名字升序排序
//再根据年龄降序排序
List<Person> sortedPersons = persons.stream()
                .sorted(Comparator.comparing(Person::getName)
                .thenComparing(Comparator.comparing(Person::getAge).reversed()))
                .collect(Collectors.toList());
```
